// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.4.8
// - protoc                        v3.19.3
// source: test_conf.proto

#include "test_conf.pc.h"

namespace tableau {
const std::string ActivityConf::kProtoName = "ActivityConf";

bool ActivityConf::Load(const std::string& dir, Format fmt, const LoadOptions* options /* = nullptr */) {
  bool ok = LoadMessage(dir, data_, fmt, options);
  return ok ? ProcessAfterLoad() : false;
}

bool ActivityConf::ProcessAfterLoad() {
  // OrderedMap init.
  for (auto&& item1 : data_.activity_map()) {
    ordered_map_[item1.first] = Activity_OrderedMapValue(Activity_Chapter_OrderedMap(), &item1.second);
    auto&& ordered_map1 = ordered_map_[item1.first].first;
    for (auto&& item2 : item1.second.chapter_map()) {
      ordered_map1[item2.first] = Activity_Chapter_OrderedMapValue(protoconf_Section_OrderedMap(), &item2.second);
      auto&& ordered_map2 = ordered_map1[item2.first].first;
      for (auto&& item3 : item2.second.section_map()) {
        ordered_map2[item3.first] = protoconf_Section_OrderedMapValue(int32_OrderedMap(), &item3.second);
        auto&& ordered_map3 = ordered_map2[item3.first].first;
        for (auto&& item4 : item3.second.section_rank_map()) {
          ordered_map3[item4.first] = item4.second;
        }
      }
    }
  }

  // Index init.
  // Index: ChapterID
  for (auto&& item1 : data_.activity_map()) {
    for (auto&& item2 : item1.second.chapter_map()) {
      index_chapter_map_[item2.second.chapter_id()].push_back(&item2.second);
    }
  }

  // Index: ChapterName@NamedChapter
  for (auto&& item1 : data_.activity_map()) {
    for (auto&& item2 : item1.second.chapter_map()) {
      index_named_chapter_map_[item2.second.chapter_name()].push_back(&item2.second);
    }
  }

  // Index: SectionItemId@Award
  for (auto&& item1 : data_.activity_map()) {
    for (auto&& item2 : item1.second.chapter_map()) {
      for (auto&& item3 : item2.second.section_map()) {
        for (auto&& item4 : item3.second.section_item_list()) {
          index_award_map_[item4.id()].push_back(&item4);
        }
      }
    }
  }

  return true;
}

const protoconf::ActivityConf::Activity* ActivityConf::Get(uint64_t activity_id) const {
  auto iter = data_.activity_map().find(activity_id);
  if (iter == data_.activity_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ActivityConf::Activity::Chapter* ActivityConf::Get(uint64_t activity_id, uint32_t chapter_id) const {
  const auto* conf = Get(activity_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->chapter_map().find(chapter_id);
  if (iter == conf->chapter_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::Section* ActivityConf::Get(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id) const {
  const auto* conf = Get(activity_id, chapter_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->section_map().find(section_id);
  if (iter == conf->section_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const int32_t* ActivityConf::Get(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id, uint32_t key4) const {
  const auto* conf = Get(activity_id, chapter_id, section_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->section_rank_map().find(key4);
  if (iter == conf->section_rank_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const ActivityConf::Activity_OrderedMap* ActivityConf::GetOrderedMap() const {
  return &ordered_map_; 
}

const ActivityConf::Activity_Chapter_OrderedMap* ActivityConf::GetOrderedMap(uint64_t activity_id) const {
  const auto* conf = GetOrderedMap();
  if (conf == nullptr) {
    return nullptr;
  }

  auto iter = conf->find(activity_id);
  if (iter == conf->end()) {
    return nullptr;
  }
  return &iter->second.first;
}

const ActivityConf::protoconf_Section_OrderedMap* ActivityConf::GetOrderedMap(uint64_t activity_id, uint32_t chapter_id) const {
  const auto* conf = GetOrderedMap(activity_id);
  if (conf == nullptr) {
    return nullptr;
  }

  auto iter = conf->find(chapter_id);
  if (iter == conf->end()) {
    return nullptr;
  }
  return &iter->second.first;
}

const ActivityConf::int32_OrderedMap* ActivityConf::GetOrderedMap(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id) const {
  const auto* conf = GetOrderedMap(activity_id, chapter_id);
  if (conf == nullptr) {
    return nullptr;
  }

  auto iter = conf->find(section_id);
  if (iter == conf->end()) {
    return nullptr;
  }
  return &iter->second.first;
}

// Index: ChapterID
const ActivityConf::Index_ChapterMap& ActivityConf::FindChapter() const { return index_chapter_map_ ;}

const ActivityConf::Index_ChapterVector* ActivityConf::FindChapter(uint32_t chapter_id) const {
  auto iter = index_chapter_map_.find(chapter_id);
  if (iter == index_chapter_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ActivityConf::Activity::Chapter* ActivityConf::FindFirstChapter(uint32_t chapter_id) const {
  auto conf = FindChapter(chapter_id);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: ChapterName@NamedChapter
const ActivityConf::Index_NamedChapterMap& ActivityConf::FindNamedChapter() const { return index_named_chapter_map_ ;}

const ActivityConf::Index_NamedChapterVector* ActivityConf::FindNamedChapter(const std::string& chapter_name) const {
  auto iter = index_named_chapter_map_.find(chapter_name);
  if (iter == index_named_chapter_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ActivityConf::Activity::Chapter* ActivityConf::FindFirstNamedChapter(const std::string& chapter_name) const {
  auto conf = FindNamedChapter(chapter_name);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: SectionItemId@Award
const ActivityConf::Index_AwardMap& ActivityConf::FindAward() const { return index_award_map_ ;}

const ActivityConf::Index_AwardVector* ActivityConf::FindAward(uint32_t id) const {
  auto iter = index_award_map_.find(id);
  if (iter == index_award_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::Item* ActivityConf::FindFirstAward(uint32_t id) const {
  auto conf = FindAward(id);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}


const std::string ChapterConf::kProtoName = "ChapterConf";

bool ChapterConf::Load(const std::string& dir, Format fmt, const LoadOptions* options /* = nullptr */) {
  bool ok = LoadMessage(dir, data_, fmt, options);
  return ok ? ProcessAfterLoad() : false;
}

const protoconf::ChapterConf::Chapter* ChapterConf::Get(uint64_t id) const {
  auto iter = data_.chapter_map().find(id);
  if (iter == data_.chapter_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const std::string ThemeConf::kProtoName = "ThemeConf";

bool ThemeConf::Load(const std::string& dir, Format fmt, const LoadOptions* options /* = nullptr */) {
  bool ok = LoadMessage(dir, data_, fmt, options);
  return ok ? ProcessAfterLoad() : false;
}

const protoconf::ThemeConf::Theme* ThemeConf::Get(const std::string& name) const {
  auto iter = data_.theme_map().find(name);
  if (iter == data_.theme_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

}  // namespace tableau
