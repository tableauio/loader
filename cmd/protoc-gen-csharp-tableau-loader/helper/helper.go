package helper

import (
	"fmt"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/tableauio/tableau/proto/tableaupb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func GenerateFileHeader(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, version string) {
	g.P("// <auto-generated>")
	g.P("// Code generated by protoc-gen-csharp-tableau-loader. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-csharp-tableau-loader v", version)
	g.P("// - protoc                           ", protocVersion(gen))
	if file != nil {
		if file.Proto.GetOptions().GetDeprecated() {
			g.P("// ", file.Desc.Path(), " is a deprecated file.")
		} else {
			g.P("// source: ", file.Desc.Path())
		}
	}
	g.P("// </auto-generated>")
	g.P("#nullable enable")
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func ParseIndexFieldName(fd protoreflect.FieldDescriptor) string {
	return strcase.ToCamel(string(fd.Name()))
}

func ParseIndexFieldNameAsKeyStructFieldName(fd protoreflect.FieldDescriptor) string {
	if fd.IsList() {
		opts := fd.Options().(*descriptorpb.FieldOptions)
		fdOpts := proto.GetExtension(opts, tableaupb.E_Field).(*tableaupb.FieldOptions)
		return strcase.ToCamel(fdOpts.GetName())
	}
	return ParseIndexFieldName(fd)
}

func ParseIndexFieldNameAsFuncParam(fd protoreflect.FieldDescriptor) string {
	return escapeIdentifier(strcase.ToLowerCamel(ParseIndexFieldNameAsKeyStructFieldName(fd)))
}

// ParseCsharpType converts a FieldDescriptor to C# type string.
func ParseCsharpType(fd protoreflect.FieldDescriptor) string {
	switch fd.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		fullname := string(fd.Enum().FullName())
		seps := strings.Split(fullname, ".")
		seps[0] = strcase.ToCamel(seps[0])
		for i := 2; i < len(seps); i++ {
			seps[i] = "Types." + seps[i]
		}
		return strings.Join(seps, ".")
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "long"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "ulong"
	case protoreflect.FloatKind:
		return "float"
	case protoreflect.DoubleKind:
		return "double"
	case protoreflect.StringKind, protoreflect.BytesKind:
		return "string"
	case protoreflect.MessageKind:
		return ParseCsharpClassType(fd.Message())
	// case protoreflect.GroupKind:
	// 	return "group"
	default:
		return fmt.Sprintf("<unknown:%d>", fd.Kind())
	}
}

func ParseCsharpClassType(md protoreflect.MessageDescriptor) string {
	fullname := string(md.FullName())
	seps := strings.Split(fullname, ".")
	seps[0] = strcase.ToCamel(seps[0])
	for i := 2; i < len(seps); i++ {
		seps[i] = "Types." + seps[i]
	}
	return strings.Join(seps, ".")
}

// ParseOrderedIndexKeyType converts a FieldDescriptor to its treemap key type.
// fd must be an ordered type, or a message which can be converted to an ordered type.
func ParseOrderedIndexKeyType(fd protoreflect.FieldDescriptor) string {
	switch fd.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "long"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "ulong"
	case protoreflect.FloatKind:
		return "float"
	case protoreflect.DoubleKind:
		return "double"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.EnumKind:
		fullname := string(fd.Enum().FullName())
		seps := strings.Split(fullname, ".")
		seps[0] = strcase.ToCamel(seps[0])
		for i := 2; i < len(seps); i++ {
			seps[i] = "Types." + seps[i]
		}
		return strings.Join(seps, ".")
	case protoreflect.MessageKind:
		switch fd.Message().FullName() {
		case "google.protobuf.Timestamp", "google.protobuf.Duration":
			return "long"
		default:
		}
		fallthrough
	default:
		panic(fmt.Sprintf("unsupported kind: %d", fd.Kind()))
	}
}

func ParseMapFieldNameAsKeyStructFieldName(fd protoreflect.FieldDescriptor) string {
	opts := fd.Options().(*descriptorpb.FieldOptions)
	fdOpts := proto.GetExtension(opts, tableaupb.E_Field).(*tableaupb.FieldOptions)
	name := fdOpts.GetKey()
	if fd.MapValue().Kind() == protoreflect.MessageKind {
		valueFd := fd.MapValue().Message().Fields().Get(0)
		name = string(valueFd.Name())
	}
	return strcase.ToCamel(name)
}

func ParseMapFieldNameAsFuncParam(fd protoreflect.FieldDescriptor) string {
	fieldName := ParseMapFieldNameAsKeyStructFieldName(fd)
	if fieldName == "" {
		return fieldName
	}
	return escapeIdentifier(fieldName)
}

func ParseMapKeyType(fd protoreflect.FieldDescriptor) string {
	return ParseCsharpType(fd)
}

func ParseMapValueType(fd protoreflect.FieldDescriptor) string {
	return ParseCsharpType(fd.MapValue())
}

func GetTypeEmptyValue(fd protoreflect.FieldDescriptor) string {
	switch fd.Kind() {
	case protoreflect.BoolKind:
		return "false"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Uint32Kind, protoreflect.Fixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
		protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.EnumKind:
		return "0"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return "0.0"
	case protoreflect.StringKind:
		return `""`
	case protoreflect.BytesKind, protoreflect.MessageKind:
		return "null"
	// case protoreflect.GroupKind:
	// 	return "group"
	default:
		return fmt.Sprintf("<unknown:%d>", fd.Kind())
	}
}

func ParseLeveledMapPrefix(md protoreflect.MessageDescriptor, mapFd protoreflect.FieldDescriptor) string {
	if mapFd.MapValue().Kind() == protoreflect.MessageKind {
		localMsgProtoName := strings.TrimPrefix(string(mapFd.MapValue().Message().FullName()), string(md.FullName())+".")
		return strings.ReplaceAll(localMsgProtoName, ".", "_")
	}
	return mapFd.MapValue().Kind().String()
}

type MapKey struct {
	Type      string
	Name      string
	FieldName string // multi-colunm index only
}

type MapKeySlice []MapKey

func (s MapKeySlice) AddMapKey(newKey MapKey) MapKeySlice {
	if newKey.Name == "" {
		newKey.Name = fmt.Sprintf("key%d", len(s)+1)
	}
	for _, key := range s {
		if key.Name == newKey.Name {
			// rewrite to avoid name confict
			newKey.Name = fmt.Sprintf("%s%d", newKey.Name, len(s)+1)
			break
		}
	}
	return append(s, newKey)
}

// GenGetParams generates function parameters, which are the names listed in the function's definition.
func (s MapKeySlice) GenGetParams() string {
	return s.GenCustom(func(key MapKey) string { return key.Type + " " + key.Name }, ", ")
}

// GenGetArguments generates function arguments, which are the real values passed to the function.
func (s MapKeySlice) GenGetArguments() string {
	return s.GenCustom(func(key MapKey) string { return key.Name }, ", ")
}

func (s MapKeySlice) GenCustom(fn func(MapKey) string, sep string) string {
	var params []string
	for _, key := range s {
		params = append(params, fn(key))
	}
	return strings.Join(params, sep)
}

func Indent(depth int) string {
	return strings.Repeat("    ", depth)
}
