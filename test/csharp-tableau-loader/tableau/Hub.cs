// <auto-generated>
// Code generated by protoc-gen-csharp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-csharp-tableau-loader v0.1.0
// - protoc                           v3.19.3
// </auto-generated>
#nullable enable
using pb = global::Google.Protobuf;
namespace Tableau
{
    public enum Format
    {
        Unknown,
        JSON,
        Bin
    }

    public class LoadOptions
    {
        public bool IgnoreUnknownFields { get; set; } = false;
        public Func<string, byte[]> ReadFunc { get; set; } = File.ReadAllBytes;
    }

    public interface IMessagerName
    {
        static abstract string Name();
    }

    public abstract class Messager
    {
        public class Stats
        {
            public TimeSpan Duration;
        }

        protected Stats LoadStats = new();

        public ref Stats GetStats() => ref LoadStats;

        public abstract bool Load(string dir, Format fmt, in LoadOptions? options = null);

        protected virtual bool ProcessAfterLoad() => true;

        public virtual bool ProcessAfterLoadAll(in Hub hub) => true;

        internal static bool LoadMessageByPath<T>(out T msg, string dir, Format fmt, in LoadOptions? options = null) where T : pb::IMessage<T>, new()
        {
            msg = new T();
            string name = msg.Descriptor.Name;
            string path = Path.Combine(dir, name + Format2Ext(fmt));
            try
            {
                var readFunc = options is null ? File.ReadAllBytes : options.ReadFunc;
                byte[] content = readFunc(path);
                switch (fmt)
                {
                    case Format.JSON:
                        {
                            var parser = options is null ? pb::JsonParser.Default : new pb::JsonParser(pb::JsonParser.Settings.Default.WithIgnoreUnknownFields(options.IgnoreUnknownFields));
                            msg = parser.Parse<T>(System.Text.Encoding.UTF8.GetString(content));
                            break;
                        }
                    case Format.Bin:
                        {
                            var parser = new pb::MessageParser<T>(() => new T());
                            msg = parser.ParseFrom(content);
                            break;
                        }
                    default:
                        return false;
                }
            }
            catch (Exception)
            {
                return false;
            }
            return true;
        }

        internal static string Format2Ext(Format fmt)
        {
            return fmt switch
            {
                Format.JSON => ".json",
                Format.Bin => ".bin",
                _ => ".unknown",
            };
        }
    }

    internal class MessagerContainer
    {
        public Dictionary<string, Messager> MessagerMap;
        public DateTime LastLoadedTime;
        public HeroConf? HeroConf;
        public HeroBaseConf? HeroBaseConf;
        public ItemConf? ItemConf;
        public PatchReplaceConf? PatchReplaceConf;
        public PatchMergeConf? PatchMergeConf;
        public RecursivePatchConf? RecursivePatchConf;
        public ActivityConf? ActivityConf;
        public ChapterConf? ChapterConf;
        public ThemeConf? ThemeConf;
        public TaskConf? TaskConf;

        public MessagerContainer(in Dictionary<string, Messager>? messagerMap = null)
        {
            MessagerMap = messagerMap ?? [];
            LastLoadedTime = DateTime.Now;
            if (messagerMap != null)
            {
                HeroConf = Get<HeroConf>();
                HeroBaseConf = Get<HeroBaseConf>();
                ItemConf = Get<ItemConf>();
                PatchReplaceConf = Get<PatchReplaceConf>();
                PatchMergeConf = Get<PatchMergeConf>();
                RecursivePatchConf = Get<RecursivePatchConf>();
                ActivityConf = Get<ActivityConf>();
                ChapterConf = Get<ChapterConf>();
                ThemeConf = Get<ThemeConf>();
                TaskConf = Get<TaskConf>();
            }
        }

        public T? Get<T>() where T : Messager, IMessagerName => MessagerMap.TryGetValue(T.Name(), out var messager) ? (T)messager : null;
    }

    public class HubOptions
    {
        public Func<string, bool>? Filter { get; set; }
    }

    public class Hub(HubOptions? options = null)
    {
        private MessagerContainer MessagerContainer = new();
        private readonly HubOptions Options = options ?? new HubOptions();

        public bool Load(string dir, Format fmt, in LoadOptions? options = null)
        {
            var messagerMap = NewMessagerMap();
            foreach (var messager in messagerMap.Values)
            {
                if (!messager.Load(dir, fmt, options))
                {
                    return false;
                }
            }
            var tmpHub = new Hub();
            tmpHub.SetMessagerMap(messagerMap);
            foreach (var messager in messagerMap.Values)
            {
                if (!messager.ProcessAfterLoadAll(tmpHub))
                {
                    return false;
                }
            }
            SetMessagerMap(messagerMap);
            return true;
        }

        public ref Dictionary<string, Messager> GetMessagerMap() => ref MessagerContainer.MessagerMap;

        public void SetMessagerMap(in Dictionary<string, Messager> map) => MessagerContainer = new MessagerContainer(map);

        public T? Get<T>() where T : Messager, IMessagerName => MessagerContainer.Get<T>();

        public HeroConf? GetHeroConf() => MessagerContainer.HeroConf;

        public HeroBaseConf? GetHeroBaseConf() => MessagerContainer.HeroBaseConf;

        public ItemConf? GetItemConf() => MessagerContainer.ItemConf;

        public PatchReplaceConf? GetPatchReplaceConf() => MessagerContainer.PatchReplaceConf;

        public PatchMergeConf? GetPatchMergeConf() => MessagerContainer.PatchMergeConf;

        public RecursivePatchConf? GetRecursivePatchConf() => MessagerContainer.RecursivePatchConf;

        public ActivityConf? GetActivityConf() => MessagerContainer.ActivityConf;

        public ChapterConf? GetChapterConf() => MessagerContainer.ChapterConf;

        public ThemeConf? GetThemeConf() => MessagerContainer.ThemeConf;

        public TaskConf? GetTaskConf() => MessagerContainer.TaskConf;

        public DateTime GetLastLoadedTime() => MessagerContainer.LastLoadedTime;

        private Dictionary<string, Messager> NewMessagerMap()
        {
            var messagerMap = new Dictionary<string, Messager>();
            foreach (var kv in Registry.Registrar)
            {
                if (Options.Filter?.Invoke(kv.Key) ?? true)
                {
                    messagerMap[kv.Key] = kv.Value();
                }
            }
            return messagerMap;
        }
    }

    public class Registry
    {
        internal static readonly Dictionary<string, Func<Messager>> Registrar = [];

        public static void Register<T>() where T : Messager, IMessagerName, new() => Registrar[T.Name()] = () => new T();

        public static void Init()
        {
            Register<HeroConf>();
            Register<HeroBaseConf>();
            Register<ItemConf>();
            Register<PatchReplaceConf>();
            Register<PatchMergeConf>();
            Register<RecursivePatchConf>();
            Register<ActivityConf>();
            Register<ChapterConf>();
            Register<ThemeConf>();
            Register<TaskConf>();
        }
    }
}
