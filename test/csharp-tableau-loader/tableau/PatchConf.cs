// Code generated by protoc-gen-csharp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-csharp-tableau-loader v0.1.0
// - protoc                           v3.19.3
// source: patch_conf.proto
using System;
using System.Collections.Generic;
using Google.Protobuf;
using Google.Protobuf.Collections;

namespace Tableau
{
    public class PatchReplaceConf : Messager, IMessagerName
    {
        private Protoconf.PatchReplaceConf Data_ = new Protoconf.PatchReplaceConf();

        public static string Name() => Protoconf.PatchReplaceConf.Descriptor.Name;

        public override bool Load(string dir, Format fmt, in LoadOptions? options = null)
        {
            var start = DateTime.Now;
            bool loaded = LoadMessageByPath<Protoconf.PatchReplaceConf>(out var msg, dir, fmt, options);
            Data_ = msg;
            bool ok = loaded ? ProcessAfterLoad() : false;
            LoadStats.Duration = DateTime.Now - start;
            return ok;
        }

        public ref readonly Protoconf.PatchReplaceConf Data() => ref Data_;
    }

    public class PatchMergeConf : Messager, IMessagerName
    {
        private Protoconf.PatchMergeConf Data_ = new Protoconf.PatchMergeConf();

        public static string Name() => Protoconf.PatchMergeConf.Descriptor.Name;

        public override bool Load(string dir, Format fmt, in LoadOptions? options = null)
        {
            var start = DateTime.Now;
            bool loaded = LoadMessageByPath<Protoconf.PatchMergeConf>(out var msg, dir, fmt, options);
            Data_ = msg;
            bool ok = loaded ? ProcessAfterLoad() : false;
            LoadStats.Duration = DateTime.Now - start;
            return ok;
        }

        public ref readonly Protoconf.PatchMergeConf Data() => ref Data_;

        public Protoconf.Item? Get1(uint id)
        {
            if (Data_.ItemMap.TryGetValue(id, out var val))
            {
                return val;
            }
            return null;
        }
    }

    public class RecursivePatchConf : Messager, IMessagerName
    {
        private Protoconf.RecursivePatchConf Data_ = new Protoconf.RecursivePatchConf();

        public static string Name() => Protoconf.RecursivePatchConf.Descriptor.Name;

        public override bool Load(string dir, Format fmt, in LoadOptions? options = null)
        {
            var start = DateTime.Now;
            bool loaded = LoadMessageByPath<Protoconf.RecursivePatchConf>(out var msg, dir, fmt, options);
            Data_ = msg;
            bool ok = loaded ? ProcessAfterLoad() : false;
            LoadStats.Duration = DateTime.Now - start;
            return ok;
        }

        public ref readonly Protoconf.RecursivePatchConf Data() => ref Data_;

        public Protoconf.RecursivePatchConf.Types.Shop? Get1(uint shopId)
        {
            if (Data_.ShopMap.TryGetValue(shopId, out var val))
            {
                return val;
            }
            return null;
        }

        public Protoconf.RecursivePatchConf.Types.Shop.Types.Goods? Get2(uint shopId, uint goodsId)
        {
            var conf = Get1(shopId);
            if (conf?.GoodsMap != null && conf.GoodsMap.TryGetValue(goodsId, out var val))
            {
                return val;
            }
            return null;
        }

        public Protoconf.RecursivePatchConf.Types.Shop.Types.Goods.Types.Currency? Get3(uint shopId, uint goodsId, uint type)
        {
            var conf = Get2(shopId, goodsId);
            if (conf?.CurrencyMap != null && conf.CurrencyMap.TryGetValue(type, out var val))
            {
                return val;
            }
            return null;
        }

        public int? Get4(uint shopId, uint goodsId, uint type, int key4)
        {
            var conf = Get3(shopId, goodsId, type);
            if (conf?.ValueList != null && conf.ValueList.TryGetValue(key4, out var val))
            {
                return val;
            }
            return null;
        }
    }
}
