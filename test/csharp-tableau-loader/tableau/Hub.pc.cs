// <auto-generated>
// Code generated by protoc-gen-csharp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-csharp-tableau-loader v0.1.0
// - protoc                           v3.19.3
// </auto-generated>
#nullable enable
using pb = global::Google.Protobuf;
namespace Tableau
{
    internal class MessagerContainer(in Dictionary<string, Messager>? messagerMap = null)
    {
        public Dictionary<string, Messager> MessagerMap = messagerMap ?? [];
        public DateTime LastLoadedTime = DateTime.Now;
        public HeroConf? HeroConf = InternalGet<HeroConf>(messagerMap);
        public HeroBaseConf? HeroBaseConf = InternalGet<HeroBaseConf>(messagerMap);
        public FruitConf? FruitConf = InternalGet<FruitConf>(messagerMap);
        public Fruit2Conf? Fruit2Conf = InternalGet<Fruit2Conf>(messagerMap);
        public Fruit3Conf? Fruit3Conf = InternalGet<Fruit3Conf>(messagerMap);
        public ItemConf? ItemConf = InternalGet<ItemConf>(messagerMap);
        public PatchReplaceConf? PatchReplaceConf = InternalGet<PatchReplaceConf>(messagerMap);
        public PatchMergeConf? PatchMergeConf = InternalGet<PatchMergeConf>(messagerMap);
        public RecursivePatchConf? RecursivePatchConf = InternalGet<RecursivePatchConf>(messagerMap);
        public ActivityConf? ActivityConf = InternalGet<ActivityConf>(messagerMap);
        public ChapterConf? ChapterConf = InternalGet<ChapterConf>(messagerMap);
        public ThemeConf? ThemeConf = InternalGet<ThemeConf>(messagerMap);
        public TaskConf? TaskConf = InternalGet<TaskConf>(messagerMap);

        public T? Get<T>() where T : Messager, IMessagerName => InternalGet<T>(MessagerMap);

        private static T? InternalGet<T>(in Dictionary<string, Messager>? messagerMap) where T : Messager, IMessagerName =>
           messagerMap?.TryGetValue(T.Name(), out var messager) == true ? (T)messager : null;
    }

    internal class Atomic<T> where T : class
    {
        private T? _value;

        public T? Value
        {
            get => Interlocked.CompareExchange(ref _value, null, null);
            set => Interlocked.Exchange(ref _value, value);
        }
    }

    public class HubOptions
    {
        public Func<string, bool>? Filter { get; set; }
    }

    public class Hub(HubOptions? options = null)
    {
        private readonly Atomic<MessagerContainer> _messagerContainer = new();
        private readonly HubOptions? _options = options;

        public bool Load(string dir, Format fmt, in Load.Options? options = null)
        {
            var messagerMap = NewMessagerMap();
            var opts = options ?? new Load.Options();
            foreach (var kvs in messagerMap)
            {
                string name = kvs.Key;
                if (!kvs.Value.Load(dir, fmt, opts.ParseMessagerOptionsByName(name)))
                {
                    return false;
                }
            }
            var tmpHub = new Hub();
            tmpHub.SetMessagerMap(messagerMap);
            foreach (var messager in messagerMap.Values)
            {
                if (!messager.ProcessAfterLoadAll(tmpHub))
                {
                    return false;
                }
            }
            SetMessagerMap(messagerMap);
            return true;
        }

        public IReadOnlyDictionary<string, Messager>? GetMessagerMap() => _messagerContainer.Value?.MessagerMap;

        public void SetMessagerMap(in Dictionary<string, Messager> map) => _messagerContainer.Value = new MessagerContainer(map);

        public T? Get<T>() where T : Messager, IMessagerName => _messagerContainer.Value?.Get<T>();

        public HeroConf? GetHeroConf() => _messagerContainer.Value?.HeroConf;

        public HeroBaseConf? GetHeroBaseConf() => _messagerContainer.Value?.HeroBaseConf;

        public FruitConf? GetFruitConf() => _messagerContainer.Value?.FruitConf;

        public Fruit2Conf? GetFruit2Conf() => _messagerContainer.Value?.Fruit2Conf;

        public Fruit3Conf? GetFruit3Conf() => _messagerContainer.Value?.Fruit3Conf;

        public ItemConf? GetItemConf() => _messagerContainer.Value?.ItemConf;

        public PatchReplaceConf? GetPatchReplaceConf() => _messagerContainer.Value?.PatchReplaceConf;

        public PatchMergeConf? GetPatchMergeConf() => _messagerContainer.Value?.PatchMergeConf;

        public RecursivePatchConf? GetRecursivePatchConf() => _messagerContainer.Value?.RecursivePatchConf;

        public ActivityConf? GetActivityConf() => _messagerContainer.Value?.ActivityConf;

        public ChapterConf? GetChapterConf() => _messagerContainer.Value?.ChapterConf;

        public ThemeConf? GetThemeConf() => _messagerContainer.Value?.ThemeConf;

        public TaskConf? GetTaskConf() => _messagerContainer.Value?.TaskConf;

        public DateTime? GetLastLoadedTime() => _messagerContainer.Value?.LastLoadedTime;

        private Dictionary<string, Messager> NewMessagerMap()
        {
            var messagerMap = new Dictionary<string, Messager>();
            foreach (var kv in Registry.Registrar)
            {
                if (_options?.Filter?.Invoke(kv.Key) ?? true)
                {
                    messagerMap[kv.Key] = kv.Value();
                }
            }
            return messagerMap;
        }
    }

    public class Registry
    {
        internal static readonly Dictionary<string, Func<Messager>> Registrar = [];

        public static void Register<T>() where T : Messager, IMessagerName, new() => Registrar[T.Name()] = () => new T();

        public static void Init()
        {
            Register<HeroConf>();
            Register<HeroBaseConf>();
            Register<FruitConf>();
            Register<Fruit2Conf>();
            Register<Fruit3Conf>();
            Register<ItemConf>();
            Register<PatchReplaceConf>();
            Register<PatchMergeConf>();
            Register<RecursivePatchConf>();
            Register<ActivityConf>();
            Register<ChapterConf>();
            Register<ThemeConf>();
            Register<TaskConf>();
        }
    }
}
