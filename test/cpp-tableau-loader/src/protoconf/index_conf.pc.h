// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.10.1
// - protoc                        v3.19.3
// source: index_conf.proto

#pragma once
#include <filesystem>
#include <string>

#include "load.pc.h"
#include "util.pc.h"
#include "index_conf.pb.h"

namespace tableau {
class FruitConf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::FruitConf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 private:
  virtual bool ProcessAfterLoad() override final;

 public:
  const protoconf::FruitConf::Fruit* Get(int32_t fruit_type) const;
  const protoconf::FruitConf::Fruit::Item* Get(int32_t fruit_type, int32_t id) const;

 private:
  static const std::string kProtoName;
  protoconf::FruitConf data_;

  // OrderedIndex accessers.
  // OrderedIndex: Price<ID>
 public:
  using OrderedIndex_ItemVector = std::vector<const protoconf::FruitConf::Fruit::Item*>;
  using OrderedIndex_ItemMap = std::map<int32_t, OrderedIndex_ItemVector>;
  // Finds the ordered index: key(Price<ID>) to value(OrderedIndex_ItemVector) map.
  // One key may correspond to multiple values, which are represented by a vector.
  const OrderedIndex_ItemMap& FindItemMap() const;
  // Finds a vector of all values of the given key(s).
  const OrderedIndex_ItemVector* FindItem(int32_t price) const;
  // Finds the first value of the given key(s).
  const protoconf::FruitConf::Fruit::Item* FindFirstItem(int32_t price) const;
  // Finds the ordered index: key(Price<ID>) to value(OrderedIndex_ItemVector),
  // which is the upper 1st-level map specified by (fruit_type).
  // One key may correspond to multiple values, which are represented by a vector.
  const OrderedIndex_ItemMap* FindItemMap(int32_t fruit_type) const;
  // Finds a vector of all values of the given key(s) in the upper 1st-level map specified by (fruit_type).
  const OrderedIndex_ItemVector* FindItem(int32_t fruit_type, int32_t price) const;
  // Finds the first value of the given key(s) in the upper 1st-level map specified by (fruit_type).
  const protoconf::FruitConf::Fruit::Item* FindFirstItem(int32_t fruit_type, int32_t price) const;

 private:
  OrderedIndex_ItemMap ordered_index_item_map_;
  std::unordered_map<int32_t, OrderedIndex_ItemMap> ordered_index_item_map1_;
};

class Fruit2Conf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::Fruit2Conf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 private:
  virtual bool ProcessAfterLoad() override final;

 public:
  const protoconf::Fruit2Conf::Fruit* Get(int32_t fruit_type) const;

 private:
  static const std::string kProtoName;
  protoconf::Fruit2Conf data_;

  // Index accessers.
  // Index: CountryName
 public:
  using Index_CountryVector = std::vector<const protoconf::Fruit2Conf::Fruit::Country*>;
  using Index_CountryMap = std::unordered_map<std::string, Index_CountryVector>;
  // Finds the index: key(CountryName) to value(Index_CountryVector) hashmap.
  // One key may correspond to multiple values, which are represented by a vector.
  const Index_CountryMap& FindCountryMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_CountryVector* FindCountry(const std::string& name) const;
  // Finds the first value of the given key(s).
  const protoconf::Fruit2Conf::Fruit::Country* FindFirstCountry(const std::string& name) const;

 private:
  Index_CountryMap index_country_map_;

  // Index: CountryItemAttrName
 public:
  using Index_AttrVector = std::vector<const protoconf::Fruit2Conf::Fruit::Country::Item::Attr*>;
  using Index_AttrMap = std::unordered_map<std::string, Index_AttrVector>;
  // Finds the index: key(CountryItemAttrName) to value(Index_AttrVector) hashmap.
  // One key may correspond to multiple values, which are represented by a vector.
  const Index_AttrMap& FindAttrMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_AttrVector* FindAttr(const std::string& name) const;
  // Finds the first value of the given key(s).
  const protoconf::Fruit2Conf::Fruit::Country::Item::Attr* FindFirstAttr(const std::string& name) const;
  // Finds the index: key(CountryItemAttrName) to value(Index_AttrVector),
  // which is the upper 1st-level hashmap specified by (fruit_type).
  // One key may correspond to multiple values, which are represented by a vector.
  const Index_AttrMap* FindAttrMap(int32_t fruit_type) const;
  // Finds a vector of all values of the given key(s) in the upper 1st-level hashmap specified by (fruit_type).
  const Index_AttrVector* FindAttr(int32_t fruit_type, const std::string& name) const;
  // Finds the first value of the given key(s) in the upper 1st-level hashmap specified by (fruit_type).
  const protoconf::Fruit2Conf::Fruit::Country::Item::Attr* FindFirstAttr(int32_t fruit_type, const std::string& name) const;

 private:
  Index_AttrMap index_attr_map_;
  std::unordered_map<int32_t, Index_AttrMap> index_attr_map1_;

  // OrderedIndex accessers.
  // OrderedIndex: CountryItemPrice<CountryItemID>
 public:
  using OrderedIndex_ItemVector = std::vector<const protoconf::Fruit2Conf::Fruit::Country::Item*>;
  using OrderedIndex_ItemMap = std::map<int32_t, OrderedIndex_ItemVector>;
  // Finds the ordered index: key(CountryItemPrice<CountryItemID>) to value(OrderedIndex_ItemVector) map.
  // One key may correspond to multiple values, which are represented by a vector.
  const OrderedIndex_ItemMap& FindItemMap() const;
  // Finds a vector of all values of the given key(s).
  const OrderedIndex_ItemVector* FindItem(int32_t price) const;
  // Finds the first value of the given key(s).
  const protoconf::Fruit2Conf::Fruit::Country::Item* FindFirstItem(int32_t price) const;
  // Finds the ordered index: key(CountryItemPrice<CountryItemID>) to value(OrderedIndex_ItemVector),
  // which is the upper 1st-level map specified by (fruit_type).
  // One key may correspond to multiple values, which are represented by a vector.
  const OrderedIndex_ItemMap* FindItemMap(int32_t fruit_type) const;
  // Finds a vector of all values of the given key(s) in the upper 1st-level map specified by (fruit_type).
  const OrderedIndex_ItemVector* FindItem(int32_t fruit_type, int32_t price) const;
  // Finds the first value of the given key(s) in the upper 1st-level map specified by (fruit_type).
  const protoconf::Fruit2Conf::Fruit::Country::Item* FindFirstItem(int32_t fruit_type, int32_t price) const;

 private:
  OrderedIndex_ItemMap ordered_index_item_map_;
  std::unordered_map<int32_t, OrderedIndex_ItemMap> ordered_index_item_map1_;
};

class Fruit3Conf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::Fruit3Conf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 private:
  virtual bool ProcessAfterLoad() override final;


 private:
  static const std::string kProtoName;
  protoconf::Fruit3Conf data_;

  // Index accessers.
  // Index: CountryName
 public:
  using Index_CountryVector = std::vector<const protoconf::Fruit3Conf::Fruit::Country*>;
  using Index_CountryMap = std::unordered_map<std::string, Index_CountryVector>;
  // Finds the index: key(CountryName) to value(Index_CountryVector) hashmap.
  // One key may correspond to multiple values, which are represented by a vector.
  const Index_CountryMap& FindCountryMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_CountryVector* FindCountry(const std::string& name) const;
  // Finds the first value of the given key(s).
  const protoconf::Fruit3Conf::Fruit::Country* FindFirstCountry(const std::string& name) const;

 private:
  Index_CountryMap index_country_map_;

  // Index: CountryItemAttrName
 public:
  using Index_AttrVector = std::vector<const protoconf::Fruit3Conf::Fruit::Country::Item::Attr*>;
  using Index_AttrMap = std::unordered_map<std::string, Index_AttrVector>;
  // Finds the index: key(CountryItemAttrName) to value(Index_AttrVector) hashmap.
  // One key may correspond to multiple values, which are represented by a vector.
  const Index_AttrMap& FindAttrMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_AttrVector* FindAttr(const std::string& name) const;
  // Finds the first value of the given key(s).
  const protoconf::Fruit3Conf::Fruit::Country::Item::Attr* FindFirstAttr(const std::string& name) const;

 private:
  Index_AttrMap index_attr_map_;

  // OrderedIndex accessers.
  // OrderedIndex: CountryItemPrice<CountryItemID>
 public:
  using OrderedIndex_ItemVector = std::vector<const protoconf::Fruit3Conf::Fruit::Country::Item*>;
  using OrderedIndex_ItemMap = std::map<int32_t, OrderedIndex_ItemVector>;
  // Finds the ordered index: key(CountryItemPrice<CountryItemID>) to value(OrderedIndex_ItemVector) map.
  // One key may correspond to multiple values, which are represented by a vector.
  const OrderedIndex_ItemMap& FindItemMap() const;
  // Finds a vector of all values of the given key(s).
  const OrderedIndex_ItemVector* FindItem(int32_t price) const;
  // Finds the first value of the given key(s).
  const protoconf::Fruit3Conf::Fruit::Country::Item* FindFirstItem(int32_t price) const;

 private:
  OrderedIndex_ItemMap ordered_index_item_map_;
};

}  // namespace tableau

namespace protoconf {
// Here are some type aliases for easy use.
using FruitConfMgr = tableau::FruitConf;
using Fruit2ConfMgr = tableau::Fruit2Conf;
using Fruit3ConfMgr = tableau::Fruit3Conf;
}  // namespace protoconf
