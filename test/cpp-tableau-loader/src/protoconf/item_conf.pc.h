// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.9.0
// - protoc                        v3.19.3
// source: item_conf.proto

#pragma once
#include <filesystem>
#include <string>

#include "load.pc.h"
#include "util.pc.h"
#include "item_conf.pb.h"

namespace tableau {
class ItemConf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::ItemConf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 private:
  virtual bool ProcessAfterLoad() override final;

 public:
  const protoconf::ItemConf::Item* Get(uint32_t id) const;

 private:
  static const std::string kProtoName;
  protoconf::ItemConf data_;

  // OrderedMap accessers.
 public:
  using Item_OrderedMap = std::map<uint32_t, const protoconf::ItemConf::Item*>;
  const Item_OrderedMap* GetOrderedMap() const;

 private:
  Item_OrderedMap ordered_map_;

  // Index accessers.
  // Index: Type
 public:
  using Index_ItemVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_ItemMap = std::unordered_map<protoconf::FruitType, Index_ItemVector>;
  // Finds the index (Type) to value (Index_ItemVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ItemMap& FindItem() const;
  // Finds a vector of all values of the given key.
  const Index_ItemVector* FindItem(protoconf::FruitType type) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstItem(protoconf::FruitType type) const;

 private:
  Index_ItemMap index_item_map_;

  // Index: Param<ID>@ItemInfo
 public:
  using Index_ItemInfoVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_ItemInfoMap = std::unordered_map<int32_t, Index_ItemInfoVector>;
  // Finds the index (Param<ID>@ItemInfo) to value (Index_ItemInfoVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ItemInfoMap& FindItemInfo() const;
  // Finds a vector of all values of the given key.
  const Index_ItemInfoVector* FindItemInfo(int32_t param) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstItemInfo(int32_t param) const;

 private:
  Index_ItemInfoMap index_item_info_map_;

  // Index: Default@ItemDefaultInfo
 public:
  using Index_ItemDefaultInfoVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_ItemDefaultInfoMap = std::unordered_map<std::string, Index_ItemDefaultInfoVector>;
  // Finds the index (Default@ItemDefaultInfo) to value (Index_ItemDefaultInfoVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ItemDefaultInfoMap& FindItemDefaultInfo() const;
  // Finds a vector of all values of the given key.
  const Index_ItemDefaultInfoVector* FindItemDefaultInfo(const std::string& default_) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstItemDefaultInfo(const std::string& default_) const;

 private:
  Index_ItemDefaultInfoMap index_item_default_info_map_;

  // Index: ExtType@ItemExtInfo
 public:
  using Index_ItemExtInfoVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_ItemExtInfoMap = std::unordered_map<protoconf::FruitType, Index_ItemExtInfoVector>;
  // Finds the index (ExtType@ItemExtInfo) to value (Index_ItemExtInfoVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ItemExtInfoMap& FindItemExtInfo() const;
  // Finds a vector of all values of the given key.
  const Index_ItemExtInfoVector* FindItemExtInfo(protoconf::FruitType ext_type) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstItemExtInfo(protoconf::FruitType ext_type) const;

 private:
  Index_ItemExtInfoMap index_item_ext_info_map_;

  // Index: (ID,Name)<Type,UseEffectType>@AwardItem
 public:
  struct Index_AwardItemKey {
    uint32_t id;
    std::string name;
    bool operator==(const Index_AwardItemKey& other) const {
      return id == other.id && name == other.name;
    }
  };
  struct Index_AwardItemKeyHasher {
    std::size_t operator()(const Index_AwardItemKey& key) const {
      return util::SugaredHashCombine(key.id, key.name);
    }
  };
  using Index_AwardItemVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_AwardItemMap = std::unordered_map<Index_AwardItemKey, Index_AwardItemVector, Index_AwardItemKeyHasher>;
  // Finds the index ((ID,Name)<Type,UseEffectType>@AwardItem) to value (Index_AwardItemVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_AwardItemMap& FindAwardItem() const;
  // Finds a vector of all values of the given key.
  const Index_AwardItemVector* FindAwardItem(const Index_AwardItemKey& key) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstAwardItem(const Index_AwardItemKey& key) const;

 private:
  Index_AwardItemMap index_award_item_map_;

  // Index: (ID,Type,Param,ExtType)@SpecialItem
 public:
  struct Index_SpecialItemKey {
    uint32_t id;
    protoconf::FruitType type;
    int32_t param;
    protoconf::FruitType ext_type;
    bool operator==(const Index_SpecialItemKey& other) const {
      return id == other.id && type == other.type && param == other.param && ext_type == other.ext_type;
    }
  };
  struct Index_SpecialItemKeyHasher {
    std::size_t operator()(const Index_SpecialItemKey& key) const {
      return util::SugaredHashCombine(key.id, key.type, key.param, key.ext_type);
    }
  };
  using Index_SpecialItemVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_SpecialItemMap = std::unordered_map<Index_SpecialItemKey, Index_SpecialItemVector, Index_SpecialItemKeyHasher>;
  // Finds the index ((ID,Type,Param,ExtType)@SpecialItem) to value (Index_SpecialItemVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_SpecialItemMap& FindSpecialItem() const;
  // Finds a vector of all values of the given key.
  const Index_SpecialItemVector* FindSpecialItem(const Index_SpecialItemKey& key) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstSpecialItem(const Index_SpecialItemKey& key) const;

 private:
  Index_SpecialItemMap index_special_item_map_;

  // Index: PathDir@ItemPathDir
 public:
  using Index_ItemPathDirVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_ItemPathDirMap = std::unordered_map<std::string, Index_ItemPathDirVector>;
  // Finds the index (PathDir@ItemPathDir) to value (Index_ItemPathDirVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ItemPathDirMap& FindItemPathDir() const;
  // Finds a vector of all values of the given key.
  const Index_ItemPathDirVector* FindItemPathDir(const std::string& dir) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstItemPathDir(const std::string& dir) const;

 private:
  Index_ItemPathDirMap index_item_path_dir_map_;

  // Index: PathName@ItemPathName
 public:
  using Index_ItemPathNameVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_ItemPathNameMap = std::unordered_map<std::string, Index_ItemPathNameVector>;
  // Finds the index (PathName@ItemPathName) to value (Index_ItemPathNameVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ItemPathNameMap& FindItemPathName() const;
  // Finds a vector of all values of the given key.
  const Index_ItemPathNameVector* FindItemPathName(const std::string& name) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstItemPathName(const std::string& name) const;

 private:
  Index_ItemPathNameMap index_item_path_name_map_;

  // Index: PathFriendID@ItemPathFriendID
 public:
  using Index_ItemPathFriendIDVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_ItemPathFriendIDMap = std::unordered_map<uint32_t, Index_ItemPathFriendIDVector>;
  // Finds the index (PathFriendID@ItemPathFriendID) to value (Index_ItemPathFriendIDVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ItemPathFriendIDMap& FindItemPathFriendID() const;
  // Finds a vector of all values of the given key.
  const Index_ItemPathFriendIDVector* FindItemPathFriendID(uint32_t id) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstItemPathFriendID(uint32_t id) const;

 private:
  Index_ItemPathFriendIDMap index_item_path_friend_id_map_;

  // Index: UseEffectType@UseEffectType
 public:
  using Index_UseEffectTypeVector = std::vector<const protoconf::ItemConf::Item*>;
  using Index_UseEffectTypeMap = std::unordered_map<protoconf::UseEffect::Type, Index_UseEffectTypeVector>;
  // Finds the index (UseEffectType@UseEffectType) to value (Index_UseEffectTypeVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_UseEffectTypeMap& FindUseEffectType() const;
  // Finds a vector of all values of the given key.
  const Index_UseEffectTypeVector* FindUseEffectType(protoconf::UseEffect::Type type) const;
  // Finds the first value of the given key.
  const protoconf::ItemConf::Item* FindFirstUseEffectType(protoconf::UseEffect::Type type) const;

 private:
  Index_UseEffectTypeMap index_use_effect_type_map_;

};

}  // namespace tableau

namespace protoconf {
// Here are some type aliases for easy use.
using ItemConfMgr = tableau::ItemConf;
}  // namespace protoconf
