// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.10.1
// - protoc                        v3.19.3
// source: item_conf.proto

#include "item_conf.pc.h"

#include "hub.pc.h"
#include "util.pc.h"

namespace tableau {
const std::string ItemConf::kProtoName = protoconf::ItemConf::GetDescriptor()->name();

bool ItemConf::Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options /* = nullptr */) {
  tableau::util::TimeProfiler profiler;
  bool loaded = LoadMessagerInDir(data_, dir, fmt, options);
  bool ok = loaded ? ProcessAfterLoad() : false;
  stats_.duration = profiler.Elapse();
  return ok;
}

bool ItemConf::ProcessAfterLoad() {
  // OrderedMap init.
  ordered_map_.clear();
  for (auto&& item1 : data_.item_map()) {
    ordered_map_[item1.first] = &item1.second;
  }
  // Index init.
  index_item_map_.clear();
  index_item_info_map_.clear();
  index_item_default_info_map_.clear();
  index_item_ext_info_map_.clear();
  index_award_item_map_.clear();
  index_special_item_map_.clear();
  index_item_path_dir_map_.clear();
  index_item_path_name_map_.clear();
  index_item_path_friend_id_map_.clear();
  index_use_effect_type_map_.clear();
  for (auto&& item1 : data_.item_map()) {
    {
      // Index: Type
      index_item_map_[item1.second.type()].push_back(&item1.second);
    }
    {
      // Index: Param<ID>@ItemInfo
      for (auto&& item2 : item1.second.param_list()) {
        index_item_info_map_[item2].push_back(&item1.second);
      }
    }
    {
      // Index: Default@ItemDefaultInfo
      index_item_default_info_map_[item1.second.default_()].push_back(&item1.second);
    }
    {
      // Index: ExtType@ItemExtInfo
      for (auto&& item2 : item1.second.ext_type_list()) {
        index_item_ext_info_map_[static_cast<protoconf::FruitType>(item2)].push_back(&item1.second);
      }
    }
    {
      // Index: (ID,Name)<Type,UseEffectType>@AwardItem
      Index_AwardItemKey key{item1.second.id(), item1.second.name()};
      index_award_item_map_[key].push_back(&item1.second);
    }
    {
      // Index: (ID,Type,Param,ExtType)@SpecialItem
      for (auto&& index_item2 : item1.second.param_list()) {
        for (auto&& index_item3 : item1.second.ext_type_list()) {
          Index_SpecialItemKey key{item1.second.id(), item1.second.type(), index_item2, static_cast<protoconf::FruitType>(index_item3)};
          index_special_item_map_[key].push_back(&item1.second);
        }
      }
    }
    {
      // Index: PathDir@ItemPathDir
      index_item_path_dir_map_[item1.second.path().dir()].push_back(&item1.second);
    }
    {
      // Index: PathName@ItemPathName
      for (auto&& item2 : item1.second.path().name_list()) {
        index_item_path_name_map_[item2].push_back(&item1.second);
      }
    }
    {
      // Index: PathFriendID@ItemPathFriendID
      index_item_path_friend_id_map_[item1.second.path().friend_().id()].push_back(&item1.second);
    }
    {
      // Index: UseEffectType@UseEffectType
      index_use_effect_type_map_[item1.second.use_effect().type()].push_back(&item1.second);
    }
  }
  // Index(sort): Param<ID>@ItemInfo
  auto index_item_info_map_sorter = [](const protoconf::ItemConf::Item* a,
                                       const protoconf::ItemConf::Item* b) {
    return a->id() < b->id();
  };
  for (auto&& item : index_item_info_map_) {
    std::sort(item.second.begin(), item.second.end(), index_item_info_map_sorter);
  }
  // Index(sort): (ID,Name)<Type,UseEffectType>@AwardItem
  auto index_award_item_map_sorter = [](const protoconf::ItemConf::Item* a,
                                        const protoconf::ItemConf::Item* b) {
    if (a->type() != b->type()) {
      return a->type() < b->type();
    }
    return a->use_effect().type() < b->use_effect().type();
  };
  for (auto&& item : index_award_item_map_) {
    std::sort(item.second.begin(), item.second.end(), index_award_item_map_sorter);
  }
  // OrderedIndex init.
  ordered_index_ext_type_map_.clear();
  ordered_index_param_ext_type_map_.clear();
  for (auto&& item1 : data_.item_map()) {
    {
      // OrderedIndex: ExtType@ExtType
      for (auto&& item2 : item1.second.ext_type_list()) {
        ordered_index_ext_type_map_[static_cast<protoconf::FruitType>(item2)].push_back(&item1.second);
      }
    }
    {
      // OrderedIndex: (Param,ExtType)<ID>@ParamExtType
      for (auto&& index_item0 : item1.second.param_list()) {
        for (auto&& index_item1 : item1.second.ext_type_list()) {
          OrderedIndex_ParamExtTypeKey key{index_item0, static_cast<protoconf::FruitType>(index_item1)};
          ordered_index_param_ext_type_map_[key].push_back(&item1.second);
        }
      }
    }
  }
  // OrderedIndex(sort): (Param,ExtType)<ID>@ParamExtType
  auto ordered_index_param_ext_type_map_sorter = [](const protoconf::ItemConf::Item* a,
                                                    const protoconf::ItemConf::Item* b) {
    return a->id() < b->id();
  };
  for (auto&& item : ordered_index_param_ext_type_map_) {
    std::sort(item.second.begin(), item.second.end(), ordered_index_param_ext_type_map_sorter);
  }
  return true;
}

const protoconf::ItemConf::Item* ItemConf::Get(uint32_t id) const {
  auto iter = data_.item_map().find(id);
  if (iter == data_.item_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const ItemConf::OrderedMap_ItemMap* ItemConf::GetOrderedMap() const {
  return &ordered_map_; 
}

// Index: Type
const ItemConf::Index_ItemMap& ItemConf::FindItemMap() const { return index_item_map_ ;}

const ItemConf::Index_ItemVector* ItemConf::FindItem(protoconf::FruitType type) const {
  auto iter = index_item_map_.find(type);
  if (iter == index_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItem(protoconf::FruitType type) const {
  auto conf = FindItem(type);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: Param<ID>@ItemInfo
const ItemConf::Index_ItemInfoMap& ItemConf::FindItemInfoMap() const { return index_item_info_map_ ;}

const ItemConf::Index_ItemInfoVector* ItemConf::FindItemInfo(int32_t param) const {
  auto iter = index_item_info_map_.find(param);
  if (iter == index_item_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemInfo(int32_t param) const {
  auto conf = FindItemInfo(param);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: Default@ItemDefaultInfo
const ItemConf::Index_ItemDefaultInfoMap& ItemConf::FindItemDefaultInfoMap() const { return index_item_default_info_map_ ;}

const ItemConf::Index_ItemDefaultInfoVector* ItemConf::FindItemDefaultInfo(const std::string& default_) const {
  auto iter = index_item_default_info_map_.find(default_);
  if (iter == index_item_default_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemDefaultInfo(const std::string& default_) const {
  auto conf = FindItemDefaultInfo(default_);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: ExtType@ItemExtInfo
const ItemConf::Index_ItemExtInfoMap& ItemConf::FindItemExtInfoMap() const { return index_item_ext_info_map_ ;}

const ItemConf::Index_ItemExtInfoVector* ItemConf::FindItemExtInfo(protoconf::FruitType ext_type) const {
  auto iter = index_item_ext_info_map_.find(ext_type);
  if (iter == index_item_ext_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemExtInfo(protoconf::FruitType ext_type) const {
  auto conf = FindItemExtInfo(ext_type);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: (ID,Name)<Type,UseEffectType>@AwardItem
const ItemConf::Index_AwardItemMap& ItemConf::FindAwardItemMap() const { return index_award_item_map_ ;}

const ItemConf::Index_AwardItemVector* ItemConf::FindAwardItem(uint32_t id, const std::string& name) const {
  auto iter = index_award_item_map_.find({id, name});
  if (iter == index_award_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstAwardItem(uint32_t id, const std::string& name) const {
  auto conf = FindAwardItem(id, name);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: (ID,Type,Param,ExtType)@SpecialItem
const ItemConf::Index_SpecialItemMap& ItemConf::FindSpecialItemMap() const { return index_special_item_map_ ;}

const ItemConf::Index_SpecialItemVector* ItemConf::FindSpecialItem(uint32_t id, protoconf::FruitType type, int32_t param, protoconf::FruitType ext_type) const {
  auto iter = index_special_item_map_.find({id, type, param, ext_type});
  if (iter == index_special_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstSpecialItem(uint32_t id, protoconf::FruitType type, int32_t param, protoconf::FruitType ext_type) const {
  auto conf = FindSpecialItem(id, type, param, ext_type);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: PathDir@ItemPathDir
const ItemConf::Index_ItemPathDirMap& ItemConf::FindItemPathDirMap() const { return index_item_path_dir_map_ ;}

const ItemConf::Index_ItemPathDirVector* ItemConf::FindItemPathDir(const std::string& dir) const {
  auto iter = index_item_path_dir_map_.find(dir);
  if (iter == index_item_path_dir_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemPathDir(const std::string& dir) const {
  auto conf = FindItemPathDir(dir);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: PathName@ItemPathName
const ItemConf::Index_ItemPathNameMap& ItemConf::FindItemPathNameMap() const { return index_item_path_name_map_ ;}

const ItemConf::Index_ItemPathNameVector* ItemConf::FindItemPathName(const std::string& name) const {
  auto iter = index_item_path_name_map_.find(name);
  if (iter == index_item_path_name_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemPathName(const std::string& name) const {
  auto conf = FindItemPathName(name);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: PathFriendID@ItemPathFriendID
const ItemConf::Index_ItemPathFriendIDMap& ItemConf::FindItemPathFriendIDMap() const { return index_item_path_friend_id_map_ ;}

const ItemConf::Index_ItemPathFriendIDVector* ItemConf::FindItemPathFriendID(uint32_t id) const {
  auto iter = index_item_path_friend_id_map_.find(id);
  if (iter == index_item_path_friend_id_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemPathFriendID(uint32_t id) const {
  auto conf = FindItemPathFriendID(id);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: UseEffectType@UseEffectType
const ItemConf::Index_UseEffectTypeMap& ItemConf::FindUseEffectTypeMap() const { return index_use_effect_type_map_ ;}

const ItemConf::Index_UseEffectTypeVector* ItemConf::FindUseEffectType(protoconf::UseEffect::Type type) const {
  auto iter = index_use_effect_type_map_.find(type);
  if (iter == index_use_effect_type_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstUseEffectType(protoconf::UseEffect::Type type) const {
  auto conf = FindUseEffectType(type);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// OrderedIndex: ExtType@ExtType
const ItemConf::OrderedIndex_ExtTypeMap& ItemConf::FindExtTypeMap() const { return ordered_index_ext_type_map_ ;}

const ItemConf::OrderedIndex_ExtTypeVector* ItemConf::FindExtType(protoconf::FruitType ext_type) const {
  auto iter = ordered_index_ext_type_map_.find(ext_type);
  if (iter == ordered_index_ext_type_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstExtType(protoconf::FruitType ext_type) const {
  auto conf = FindExtType(ext_type);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// OrderedIndex: (Param,ExtType)<ID>@ParamExtType
const ItemConf::OrderedIndex_ParamExtTypeMap& ItemConf::FindParamExtTypeMap() const { return ordered_index_param_ext_type_map_ ;}

const ItemConf::OrderedIndex_ParamExtTypeVector* ItemConf::FindParamExtType(int32_t param, protoconf::FruitType ext_type) const {
  auto iter = ordered_index_param_ext_type_map_.find({param, ext_type});
  if (iter == ordered_index_param_ext_type_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstParamExtType(int32_t param, protoconf::FruitType ext_type) const {
  auto conf = FindParamExtType(param, ext_type);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

const std::string FruitConf::kProtoName = protoconf::FruitConf::GetDescriptor()->name();

bool FruitConf::Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options /* = nullptr */) {
  tableau::util::TimeProfiler profiler;
  bool loaded = LoadMessagerInDir(data_, dir, fmt, options);
  bool ok = loaded ? ProcessAfterLoad() : false;
  stats_.duration = profiler.Elapse();
  return ok;
}

bool FruitConf::ProcessAfterLoad() {
  // OrderedIndex init.
  ordered_index_item_map_.clear();
  ordered_index_item_map1_.clear();
  for (auto&& item1 : data_.fruit_map()) {
    for (auto&& item2 : item1.second.item_map()) {
      {
        // OrderedIndex: Price<ID>
        ordered_index_item_map_[item2.second.price()].push_back(&item2.second);
        ordered_index_item_map1_[item1.first][item2.second.price()].push_back(&item2.second);
      }
    }
  }
  // OrderedIndex(sort): Price<ID>
  auto ordered_index_item_map_sorter = [](const protoconf::FruitConf::Fruit::Item* a,
                                          const protoconf::FruitConf::Fruit::Item* b) {
    return a->id() < b->id();
  };
  for (auto&& item : ordered_index_item_map_) {
    std::sort(item.second.begin(), item.second.end(), ordered_index_item_map_sorter);
  }
  for (auto&& item : ordered_index_item_map1_) {
    for (auto&& item1 : item.second) {
      std::sort(item1.second.begin(), item1.second.end(), ordered_index_item_map_sorter);
    }
  }
  return true;
}

const protoconf::FruitConf::Fruit* FruitConf::Get(int32_t fruit_type) const {
  auto iter = data_.fruit_map().find(fruit_type);
  if (iter == data_.fruit_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::FruitConf::Fruit::Item* FruitConf::Get(int32_t fruit_type, int32_t id) const {
  const auto* conf = Get(fruit_type);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->item_map().find(id);
  if (iter == conf->item_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

// OrderedIndex: Price<ID>
const FruitConf::OrderedIndex_ItemMap& FruitConf::FindItemMap() const { return ordered_index_item_map_ ;}

const FruitConf::OrderedIndex_ItemVector* FruitConf::FindItem(int32_t price) const {
  auto iter = ordered_index_item_map_.find(price);
  if (iter == ordered_index_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::FruitConf::Fruit::Item* FruitConf::FindFirstItem(int32_t price) const {
  auto conf = FindItem(price);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

const FruitConf::OrderedIndex_ItemMap* FruitConf::FindItemMap(int32_t fruit_type) const {
  auto iter = ordered_index_item_map1_.find(fruit_type);
  if (iter == ordered_index_item_map1_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const FruitConf::OrderedIndex_ItemVector* FruitConf::FindItem(int32_t fruit_type, int32_t price) const {
  auto map = FindItemMap(fruit_type);
  if (map == nullptr) {
    return nullptr;
  }
  auto iter = map->find(price);
  if (iter == map->end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::FruitConf::Fruit::Item* FruitConf::FindFirstItem(int32_t fruit_type, int32_t price) const {
  auto conf = FindItem(fruit_type, price);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

}  // namespace tableau
