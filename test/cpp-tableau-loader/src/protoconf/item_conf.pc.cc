// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.9.0
// - protoc                        v3.19.3
// source: item_conf.proto

#include "item_conf.pc.h"

#include "hub.pc.h"
#include "util.pc.h"

namespace tableau {
const std::string ItemConf::kProtoName = protoconf::ItemConf::GetDescriptor()->name();

bool ItemConf::Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const MessagerOptions> options /* = nullptr */) {
  tableau::util::TimeProfiler profiler;
  bool loaded = LoadMessagerInDir(data_, dir, fmt, options);
  bool ok = loaded ? ProcessAfterLoad() : false;
  stats_.duration = profiler.Elapse();
  return ok;
}

bool ItemConf::ProcessAfterLoad() {
  // OrderedMap init.
  ordered_map_.clear();
  for (auto&& item1 : data_.item_map()) {
    ordered_map_[item1.first] = &item1.second;
  }
  // Index init.
  index_item_map_.clear();
  index_item_info_map_.clear();
  index_item_default_info_map_.clear();
  index_item_ext_info_map_.clear();
  index_award_item_map_.clear();
  index_special_item_map_.clear();
  index_item_path_dir_map_.clear();
  index_item_path_name_map_.clear();
  index_item_path_friend_id_map_.clear();
  index_use_effect_type_map_.clear();
  for (auto&& item1 : data_.item_map()) {
    {
      // Index: Type
      index_item_map_[item1.second.type()].push_back(&item1.second);
    }
    {
      // Index: Param<ID>@ItemInfo
      for (auto&& item2 : item1.second.param_list()) {
        index_item_info_map_[item2].push_back(&item1.second);
      }
    }
    {
      // Index: Default@ItemDefaultInfo
      index_item_default_info_map_[item1.second.default_()].push_back(&item1.second);
    }
    {
      // Index: ExtType@ItemExtInfo
      for (auto&& item2 : item1.second.ext_type_list()) {
        index_item_ext_info_map_[static_cast<protoconf::FruitType>(item2)].push_back(&item1.second);
      }
    }
    {
      // Index: (ID,Name)<Type,UseEffectType>@AwardItem
      Index_AwardItemKey key{item1.second.id(), item1.second.name()};
      index_award_item_map_[key].push_back(&item1.second);
    }
    {
      // Index: (ID,Type,Param,ExtType)@SpecialItem
      for (auto&& index_item2 : item1.second.param_list()) {
        for (auto&& index_item3 : item1.second.ext_type_list()) {
          Index_SpecialItemKey key{item1.second.id(), item1.second.type(), index_item2, static_cast<protoconf::FruitType>(index_item3)};
          index_special_item_map_[key].push_back(&item1.second);
        }
      }
    }
    {
      // Index: PathDir@ItemPathDir
      index_item_path_dir_map_[item1.second.path().dir()].push_back(&item1.second);
    }
    {
      // Index: PathName@ItemPathName
      for (auto&& item2 : item1.second.path().name_list()) {
        index_item_path_name_map_[item2].push_back(&item1.second);
      }
    }
    {
      // Index: PathFriendID@ItemPathFriendID
      index_item_path_friend_id_map_[item1.second.path().friend_().id()].push_back(&item1.second);
    }
    {
      // Index: UseEffectType@UseEffectType
      index_use_effect_type_map_[item1.second.use_effect().type()].push_back(&item1.second);
    }
  }
  // Index(sort): Param<ID>@ItemInfo
  for (auto&& item : index_item_info_map_) {
    std::sort(item.second.begin(), item.second.end(),
              [](const protoconf::ItemConf::Item* a, const protoconf::ItemConf::Item* b) {
                return a->id() < b->id();
              });
  }
  // Index(sort): (ID,Name)<Type,UseEffectType>@AwardItem
  for (auto&& item : index_award_item_map_) {
    std::sort(item.second.begin(), item.second.end(),
              [](const protoconf::ItemConf::Item* a, const protoconf::ItemConf::Item* b) {
                if (a->type() != b->type()) {
                  return a->type() < b->type();
                }
                return a->use_effect().type() < b->use_effect().type();
              });
  }
  return true;
}

const protoconf::ItemConf::Item* ItemConf::Get(uint32_t id) const {
  auto iter = data_.item_map().find(id);
  if (iter == data_.item_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const ItemConf::Item_OrderedMap* ItemConf::GetOrderedMap() const {
  return &ordered_map_; 
}

// Index: Type
const ItemConf::Index_ItemMap& ItemConf::FindItem() const { return index_item_map_ ;}

const ItemConf::Index_ItemVector* ItemConf::FindItem(protoconf::FruitType type) const {
  auto iter = index_item_map_.find(type);
  if (iter == index_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItem(protoconf::FruitType type) const {
  auto conf = FindItem(type);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: Param<ID>@ItemInfo
const ItemConf::Index_ItemInfoMap& ItemConf::FindItemInfo() const { return index_item_info_map_ ;}

const ItemConf::Index_ItemInfoVector* ItemConf::FindItemInfo(int32_t param) const {
  auto iter = index_item_info_map_.find(param);
  if (iter == index_item_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemInfo(int32_t param) const {
  auto conf = FindItemInfo(param);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: Default@ItemDefaultInfo
const ItemConf::Index_ItemDefaultInfoMap& ItemConf::FindItemDefaultInfo() const { return index_item_default_info_map_ ;}

const ItemConf::Index_ItemDefaultInfoVector* ItemConf::FindItemDefaultInfo(const std::string& default_) const {
  auto iter = index_item_default_info_map_.find(default_);
  if (iter == index_item_default_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemDefaultInfo(const std::string& default_) const {
  auto conf = FindItemDefaultInfo(default_);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: ExtType@ItemExtInfo
const ItemConf::Index_ItemExtInfoMap& ItemConf::FindItemExtInfo() const { return index_item_ext_info_map_ ;}

const ItemConf::Index_ItemExtInfoVector* ItemConf::FindItemExtInfo(protoconf::FruitType ext_type) const {
  auto iter = index_item_ext_info_map_.find(ext_type);
  if (iter == index_item_ext_info_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemExtInfo(protoconf::FruitType ext_type) const {
  auto conf = FindItemExtInfo(ext_type);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: (ID,Name)<Type,UseEffectType>@AwardItem
const ItemConf::Index_AwardItemMap& ItemConf::FindAwardItem() const { return index_award_item_map_ ;}

const ItemConf::Index_AwardItemVector* ItemConf::FindAwardItem(const Index_AwardItemKey& key) const {
  auto iter = index_award_item_map_.find(key);
  if (iter == index_award_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstAwardItem(const Index_AwardItemKey& key) const {
  auto conf = FindAwardItem(key);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: (ID,Type,Param,ExtType)@SpecialItem
const ItemConf::Index_SpecialItemMap& ItemConf::FindSpecialItem() const { return index_special_item_map_ ;}

const ItemConf::Index_SpecialItemVector* ItemConf::FindSpecialItem(const Index_SpecialItemKey& key) const {
  auto iter = index_special_item_map_.find(key);
  if (iter == index_special_item_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstSpecialItem(const Index_SpecialItemKey& key) const {
  auto conf = FindSpecialItem(key);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: PathDir@ItemPathDir
const ItemConf::Index_ItemPathDirMap& ItemConf::FindItemPathDir() const { return index_item_path_dir_map_ ;}

const ItemConf::Index_ItemPathDirVector* ItemConf::FindItemPathDir(const std::string& dir) const {
  auto iter = index_item_path_dir_map_.find(dir);
  if (iter == index_item_path_dir_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemPathDir(const std::string& dir) const {
  auto conf = FindItemPathDir(dir);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: PathName@ItemPathName
const ItemConf::Index_ItemPathNameMap& ItemConf::FindItemPathName() const { return index_item_path_name_map_ ;}

const ItemConf::Index_ItemPathNameVector* ItemConf::FindItemPathName(const std::string& name) const {
  auto iter = index_item_path_name_map_.find(name);
  if (iter == index_item_path_name_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemPathName(const std::string& name) const {
  auto conf = FindItemPathName(name);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: PathFriendID@ItemPathFriendID
const ItemConf::Index_ItemPathFriendIDMap& ItemConf::FindItemPathFriendID() const { return index_item_path_friend_id_map_ ;}

const ItemConf::Index_ItemPathFriendIDVector* ItemConf::FindItemPathFriendID(uint32_t id) const {
  auto iter = index_item_path_friend_id_map_.find(id);
  if (iter == index_item_path_friend_id_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstItemPathFriendID(uint32_t id) const {
  auto conf = FindItemPathFriendID(id);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}

// Index: UseEffectType@UseEffectType
const ItemConf::Index_UseEffectTypeMap& ItemConf::FindUseEffectType() const { return index_use_effect_type_map_ ;}

const ItemConf::Index_UseEffectTypeVector* ItemConf::FindUseEffectType(protoconf::UseEffect::Type type) const {
  auto iter = index_use_effect_type_map_.find(type);
  if (iter == index_use_effect_type_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ItemConf::Item* ItemConf::FindFirstUseEffectType(protoconf::UseEffect::Type type) const {
  auto conf = FindUseEffectType(type);
  if (conf == nullptr || conf->size() == 0) {
    return nullptr;
  }
  return (*conf)[0];
}


}  // namespace tableau
