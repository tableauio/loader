// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.10.0
// - protoc                        v3.19.3
// source: test_conf.proto

#include "test_conf.pc.h"

#include "hub.pc.h"
#include "util.pc.h"

namespace tableau {
const std::string ActivityConf::kProtoName = protoconf::ActivityConf::GetDescriptor()->name();

bool ActivityConf::Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options /* = nullptr */) {
  tableau::util::TimeProfiler profiler;
  bool loaded = LoadMessagerInDir(data_, dir, fmt, options);
  bool ok = loaded ? ProcessAfterLoad() : false;
  stats_.duration = profiler.Elapse();
  return ok;
}

bool ActivityConf::ProcessAfterLoad() {
  // OrderedMap init.
  ordered_map_.clear();
  for (auto&& item1 : data_.activity_map()) {
    ordered_map_[item1.first] = Activity_OrderedMapValue(Activity_Chapter_OrderedMap(), &item1.second);
    auto&& ordered_map1 = ordered_map_[item1.first].first;
    for (auto&& item2 : item1.second.chapter_map()) {
      ordered_map1[item2.first] = Activity_Chapter_OrderedMapValue(protoconf_Section_OrderedMap(), &item2.second);
      auto&& ordered_map2 = ordered_map1[item2.first].first;
      for (auto&& item3 : item2.second.section_map()) {
        ordered_map2[item3.first] = protoconf_Section_OrderedMapValue(int32_OrderedMap(), &item3.second);
        auto&& ordered_map3 = ordered_map2[item3.first].first;
        for (auto&& item4 : item3.second.section_rank_map()) {
          ordered_map3[item4.first] = item4.second;
        }
      }
    }
  }
  // Index init.
  index_activity_map_.clear();
  index_chapter_map_.clear();
  index_named_chapter_map_.clear();
  index_award_map_.clear();
  for (auto&& item1 : data_.activity_map()) {
    {
      // Index: ActivityName
      index_activity_map_[item1.second.activity_name()].push_back(&item1.second);
    }
    for (auto&& item2 : item1.second.chapter_map()) {
      {
        // Index: ChapterID
        index_chapter_map_[item2.second.chapter_id()].push_back(&item2.second);
      }
      {
        // Index: ChapterName<AwardID>@NamedChapter
        index_named_chapter_map_[item2.second.chapter_name()].push_back(&item2.second);
      }
      for (auto&& item3 : item2.second.section_map()) {
        for (auto&& item4 : item3.second.section_item_list()) {
          {
            // Index: SectionItemID@Award
            index_award_map_[item4.id()].push_back(&item4);
          }
        }
      }
    }
  }
  // Index(sort): ChapterName<AwardID>@NamedChapter
  for (auto&& item : index_named_chapter_map_) {
    std::sort(item.second.begin(), item.second.end(),
              [](const protoconf::ActivityConf::Activity::Chapter* a, const protoconf::ActivityConf::Activity::Chapter* b) {
                return a->award_id() < b->award_id();
              });
  }
  return true;
}

const protoconf::ActivityConf::Activity* ActivityConf::Get(uint64_t activity_id) const {
  auto iter = data_.activity_map().find(activity_id);
  if (iter == data_.activity_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ActivityConf::Activity::Chapter* ActivityConf::Get(uint64_t activity_id, uint32_t chapter_id) const {
  const auto* conf = Get(activity_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->chapter_map().find(chapter_id);
  if (iter == conf->chapter_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::Section* ActivityConf::Get(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id) const {
  const auto* conf = Get(activity_id, chapter_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->section_map().find(section_id);
  if (iter == conf->section_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const int32_t* ActivityConf::Get(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id, uint32_t key4) const {
  const auto* conf = Get(activity_id, chapter_id, section_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->section_rank_map().find(key4);
  if (iter == conf->section_rank_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const ActivityConf::Activity_OrderedMap* ActivityConf::GetOrderedMap() const {
  return &ordered_map_; 
}

const ActivityConf::Activity_Chapter_OrderedMap* ActivityConf::GetOrderedMap(uint64_t activity_id) const {
  const auto* conf = GetOrderedMap();
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->find(activity_id);
  if (iter == conf->end()) {
    return nullptr;
  }
  return &iter->second.first;
}

const ActivityConf::protoconf_Section_OrderedMap* ActivityConf::GetOrderedMap(uint64_t activity_id, uint32_t chapter_id) const {
  const auto* conf = GetOrderedMap(activity_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->find(chapter_id);
  if (iter == conf->end()) {
    return nullptr;
  }
  return &iter->second.first;
}

const ActivityConf::int32_OrderedMap* ActivityConf::GetOrderedMap(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id) const {
  const auto* conf = GetOrderedMap(activity_id, chapter_id);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->find(section_id);
  if (iter == conf->end()) {
    return nullptr;
  }
  return &iter->second.first;
}

// Index: ActivityName
const ActivityConf::Index_ActivityMap& ActivityConf::FindActivityMap() const { return index_activity_map_ ;}

const ActivityConf::Index_ActivityVector* ActivityConf::FindActivity(const std::string& activity_name) const {
  auto iter = index_activity_map_.find(activity_name);
  if (iter == index_activity_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ActivityConf::Activity* ActivityConf::FindFirstActivity(const std::string& activity_name) const {
  auto conf = FindActivity(activity_name);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: ChapterID
const ActivityConf::Index_ChapterMap& ActivityConf::FindChapterMap() const { return index_chapter_map_ ;}

const ActivityConf::Index_ChapterVector* ActivityConf::FindChapter(uint32_t chapter_id) const {
  auto iter = index_chapter_map_.find(chapter_id);
  if (iter == index_chapter_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ActivityConf::Activity::Chapter* ActivityConf::FindFirstChapter(uint32_t chapter_id) const {
  auto conf = FindChapter(chapter_id);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: ChapterName<AwardID>@NamedChapter
const ActivityConf::Index_NamedChapterMap& ActivityConf::FindNamedChapterMap() const { return index_named_chapter_map_ ;}

const ActivityConf::Index_NamedChapterVector* ActivityConf::FindNamedChapter(const std::string& chapter_name) const {
  auto iter = index_named_chapter_map_.find(chapter_name);
  if (iter == index_named_chapter_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::ActivityConf::Activity::Chapter* ActivityConf::FindFirstNamedChapter(const std::string& chapter_name) const {
  auto conf = FindNamedChapter(chapter_name);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// Index: SectionItemID@Award
const ActivityConf::Index_AwardMap& ActivityConf::FindAwardMap() const { return index_award_map_ ;}

const ActivityConf::Index_AwardVector* ActivityConf::FindAward(uint32_t id) const {
  auto iter = index_award_map_.find(id);
  if (iter == index_award_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::Section::SectionItem* ActivityConf::FindFirstAward(uint32_t id) const {
  auto conf = FindAward(id);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}


const std::string ChapterConf::kProtoName = protoconf::ChapterConf::GetDescriptor()->name();

bool ChapterConf::Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options /* = nullptr */) {
  tableau::util::TimeProfiler profiler;
  bool loaded = LoadMessagerInDir(data_, dir, fmt, options);
  bool ok = loaded ? ProcessAfterLoad() : false;
  stats_.duration = profiler.Elapse();
  return ok;
}

const protoconf::ChapterConf::Chapter* ChapterConf::Get(uint64_t id) const {
  auto iter = data_.chapter_map().find(id);
  if (iter == data_.chapter_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const std::string ThemeConf::kProtoName = protoconf::ThemeConf::GetDescriptor()->name();

bool ThemeConf::Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options /* = nullptr */) {
  tableau::util::TimeProfiler profiler;
  bool loaded = LoadMessagerInDir(data_, dir, fmt, options);
  bool ok = loaded ? ProcessAfterLoad() : false;
  stats_.duration = profiler.Elapse();
  return ok;
}

const protoconf::ThemeConf::Theme* ThemeConf::Get(const std::string& name) const {
  auto iter = data_.theme_map().find(name);
  if (iter == data_.theme_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const std::string* ThemeConf::Get(const std::string& name, const std::string& param) const {
  const auto* conf = Get(name);
  if (conf == nullptr) {
    return nullptr;
  }
  auto iter = conf->param_map().find(param);
  if (iter == conf->param_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

const std::string TaskConf::kProtoName = protoconf::TaskConf::GetDescriptor()->name();

bool TaskConf::Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options /* = nullptr */) {
  tableau::util::TimeProfiler profiler;
  bool loaded = LoadMessagerInDir(data_, dir, fmt, options);
  bool ok = loaded ? ProcessAfterLoad() : false;
  stats_.duration = profiler.Elapse();
  return ok;
}

bool TaskConf::ProcessAfterLoad() {
  // Index init.
  index_task_map_.clear();
  for (auto&& item1 : data_.task_map()) {
    {
      // Index: ActivityID<Goal,ID>
      index_task_map_[item1.second.activity_id()].push_back(&item1.second);
    }
  }
  // Index(sort): ActivityID<Goal,ID>
  for (auto&& item : index_task_map_) {
    std::sort(item.second.begin(), item.second.end(),
              [](const protoconf::TaskConf::Task* a, const protoconf::TaskConf::Task* b) {
                if (a->goal() != b->goal()) {
                  return a->goal() < b->goal();
                }
                return a->id() < b->id();
              });
  }
  // OrderedIndex init.
  ordered_index_ordered_task_map_.clear();
  ordered_index_task_expiry_map_.clear();
  ordered_index_sorted_task_expiry_map_.clear();
  for (auto&& item1 : data_.task_map()) {
    {
      // OrderedIndex: Goal<ID>@OrderedTask
      ordered_index_ordered_task_map_[item1.second.goal()].push_back(&item1.second);
    }
    {
      // OrderedIndex: Expiry@TaskExpiry
      ordered_index_task_expiry_map_[item1.second.expiry().seconds()].push_back(&item1.second);
    }
    {
      // OrderedIndex: Expiry<Goal,ID>@SortedTaskExpiry
      ordered_index_sorted_task_expiry_map_[item1.second.expiry().seconds()].push_back(&item1.second);
    }
  }
  // OrderedIndex(sort): Goal<ID>@OrderedTask
  for (auto&& item : ordered_index_ordered_task_map_) {
    std::sort(item.second.begin(), item.second.end(),
              [](const protoconf::TaskConf::Task* a, const protoconf::TaskConf::Task* b) {
                return a->id() < b->id();
              });
  }
  // OrderedIndex(sort): Expiry<Goal,ID>@SortedTaskExpiry
  for (auto&& item : ordered_index_sorted_task_expiry_map_) {
    std::sort(item.second.begin(), item.second.end(),
              [](const protoconf::TaskConf::Task* a, const protoconf::TaskConf::Task* b) {
                if (a->goal() != b->goal()) {
                  return a->goal() < b->goal();
                }
                return a->id() < b->id();
              });
  }
  return true;
}

const protoconf::TaskConf::Task* TaskConf::Get(int64_t id) const {
  auto iter = data_.task_map().find(id);
  if (iter == data_.task_map().end()) {
    return nullptr;
  }
  return &iter->second;
}

// Index: ActivityID<Goal,ID>
const TaskConf::Index_TaskMap& TaskConf::FindTaskMap() const { return index_task_map_ ;}

const TaskConf::Index_TaskVector* TaskConf::FindTask(int64_t activity_id) const {
  auto iter = index_task_map_.find(activity_id);
  if (iter == index_task_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::TaskConf::Task* TaskConf::FindFirstTask(int64_t activity_id) const {
  auto conf = FindTask(activity_id);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}


// OrderedIndex: Goal<ID>@OrderedTask
const TaskConf::OrderedIndex_OrderedTaskMap& TaskConf::FindOrderedTask() const { return ordered_index_ordered_task_map_ ;}

const TaskConf::OrderedIndex_OrderedTaskVector* TaskConf::FindOrderedTask(int64_t goal) const {
  auto iter = ordered_index_ordered_task_map_.find(goal);
  if (iter == ordered_index_ordered_task_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::TaskConf::Task* TaskConf::FindFirstOrderedTask(int64_t goal) const {
  auto conf = FindOrderedTask(goal);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// OrderedIndex: Expiry@TaskExpiry
const TaskConf::OrderedIndex_TaskExpiryMap& TaskConf::FindTaskExpiry() const { return ordered_index_task_expiry_map_ ;}

const TaskConf::OrderedIndex_TaskExpiryVector* TaskConf::FindTaskExpiry(int64_t expiry) const {
  auto iter = ordered_index_task_expiry_map_.find(expiry);
  if (iter == ordered_index_task_expiry_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::TaskConf::Task* TaskConf::FindFirstTaskExpiry(int64_t expiry) const {
  auto conf = FindTaskExpiry(expiry);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}

// OrderedIndex: Expiry<Goal,ID>@SortedTaskExpiry
const TaskConf::OrderedIndex_SortedTaskExpiryMap& TaskConf::FindSortedTaskExpiry() const { return ordered_index_sorted_task_expiry_map_ ;}

const TaskConf::OrderedIndex_SortedTaskExpiryVector* TaskConf::FindSortedTaskExpiry(int64_t expiry) const {
  auto iter = ordered_index_sorted_task_expiry_map_.find(expiry);
  if (iter == ordered_index_sorted_task_expiry_map_.end()) {
    return nullptr;
  }
  return &iter->second;
}

const protoconf::TaskConf::Task* TaskConf::FindFirstSortedTaskExpiry(int64_t expiry) const {
  auto conf = FindSortedTaskExpiry(expiry);
  if (conf == nullptr || conf->empty()) {
    return nullptr;
  }
  return conf->front();
}


}  // namespace tableau
