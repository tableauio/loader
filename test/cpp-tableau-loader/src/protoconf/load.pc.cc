// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.10.0
// - protoc                        v3.19.3

#include "load.pc.h"

#include <google/protobuf/text_format.h>
#include <google/protobuf/util/json_util.h>

#include "logger.pc.h"
#include "util.pc.h"

namespace tableau {
namespace load {
std::shared_ptr<const MessagerOptions> Options::ParseMessagerOptionsByName(const std::string& name) const {
  std::shared_ptr<MessagerOptions> mopts = std::make_shared<MessagerOptions>();
  if (auto iter = messager_options.find(name); iter != messager_options.end() && iter->second) {
    mopts = std::make_shared<MessagerOptions>(*iter->second);
  }
  if (!mopts->ignore_unknown_fields.has_value()) {
    mopts->ignore_unknown_fields = ignore_unknown_fields;
  }
  if (mopts->patch_dirs.empty()) {
    mopts->patch_dirs = patch_dirs;
  }
  if (!mopts->mode.has_value()) {
    mopts->mode = mode;
  }
  if (!mopts->read_func) {
    mopts->read_func = read_func;
  }
  if (!mopts->load_func) {
    mopts->load_func = load_func;
  }
  return mopts;
}

// Forward declaration
bool LoadMessagerWithPatch(google::protobuf::Message& msg, const std::filesystem::path& path, Format fmt,
                           tableau::Patch patch, std::shared_ptr<const MessagerOptions> options = nullptr);

bool LoadMessager(google::protobuf::Message& msg, const std::filesystem::path& path, Format fmt,
                  std::shared_ptr<const MessagerOptions> options /* = nullptr*/) {
  options = options ? options : std::make_shared<MessagerOptions>();
  std::string content;
  bool ok = options->GetReadFunc()(path, content);
  if (!ok) {
    return false;
  }
  return Unmarshal(content, msg, fmt, options);
}

bool LoadMessagerInDir(google::protobuf::Message& msg, const std::filesystem::path& dir, Format fmt,
                       std::shared_ptr<const MessagerOptions> options /* = nullptr*/) {
  options = options ? options : std::make_shared<MessagerOptions>();
  const std::string& name = msg.GetDescriptor()->name();
  std::filesystem::path path;
  if (!options->path.empty()) {
    // path specified in Paths, then use it instead of dir.
    path = options->path;
    fmt = util::GetFormat(path);
  }
  if (path.empty()) {
    std::filesystem::path filename = name + util::Format2Ext(fmt);
    path = dir / filename;
  }

  const google::protobuf::Descriptor* descriptor = msg.GetDescriptor();
  // access the extension directly using the generated identifier
  const tableau::WorksheetOptions& worksheet_options = descriptor->options().GetExtension(tableau::worksheet);
  if (worksheet_options.patch() != tableau::PATCH_NONE) {
    return LoadMessagerWithPatch(msg, path, fmt, worksheet_options.patch(), options);
  }
  return options->GetLoadFunc()(msg, path, fmt, options);
}

bool LoadMessagerWithPatch(google::protobuf::Message& msg, const std::filesystem::path& path, Format fmt,
                           tableau::Patch patch, std::shared_ptr<const MessagerOptions> options /* = nullptr*/) {
  options = options ? options : std::make_shared<MessagerOptions>();
  auto mode = options->GetMode();
  auto load_func = options->GetLoadFunc();
  if (mode == LoadMode::kOnlyMain) {
    // ignore patch files when LoadMode::kModeOnlyMain specified
    return load_func(msg, path, fmt, nullptr);
  }
  const std::string& name = msg.GetDescriptor()->name();
  std::vector<std::filesystem::path> patch_paths;
  if (!options->patch_paths.empty()) {
    // patch path specified in PatchPaths, then use it instead of PatchDirs.
    patch_paths = options->patch_paths;
  } else {
    std::filesystem::path filename = name + util::Format2Ext(fmt);
    for (auto&& patch_dir : options->patch_dirs) {
      patch_paths.emplace_back(patch_dir / filename);
    }
  }

  std::vector<std::filesystem::path> existed_patch_paths;
  for (auto&& patch_path : patch_paths) {
    if (std::filesystem::exists(patch_path)) {
      existed_patch_paths.emplace_back(patch_path);
    }
  }
  if (existed_patch_paths.empty()) {
    if (mode == LoadMode::kOnlyPatch) {
      // just returns empty message when LoadMode::kModeOnlyPatch specified but no valid patch file provided.
      return true;
    }
    // no valid patch path provided, then just load from the "main" file.
    return load_func(msg, path, fmt, options);
  }

  switch (patch) {
    case tableau::PATCH_REPLACE: {
      // just use the last "patch" file
      std::filesystem::path& patch_path = existed_patch_paths.back();
      if (!load_func(msg, patch_path, util::GetFormat(patch_path), options)) {
        return false;
      }
      break;
    }
    case tableau::PATCH_MERGE: {
      if (mode != LoadMode::kOnlyPatch) {
        // load msg from the "main" file
        if (!load_func(msg, path, fmt, options)) {
          return false;
        }
      }
      // Create a new instance of the same type of the original message
      google::protobuf::Message* patch_msg_ptr = msg.New();
      std::unique_ptr<google::protobuf::Message> _auto_release(msg.New());
      // load patch_msg from each "patch" file
      for (auto&& patch_path : existed_patch_paths) {
        if (!load_func(*patch_msg_ptr, patch_path, util::GetFormat(patch_path), options)) {
          return false;
        }
        if (!util::PatchMessage(msg, *patch_msg_ptr)) {
          return false;
        }
      }
      break;
    }
    default: {
      SetErrMsg("unknown patch type: " + tableau::Patch_Name(patch));
      return false;
    }
  }
  ATOM_DEBUG("patched(%s) %s by %s: %s", tableau::Patch_Name(patch).c_str(), name.c_str(),
             ATOM_VECTOR_STR(existed_patch_paths).c_str(), msg.ShortDebugString().c_str());
  return true;
}

bool Unmarshal(const std::string& content, google::protobuf::Message& msg, Format fmt,
               std::shared_ptr<const MessagerOptions> options /* = nullptr*/) {
  options = options ? options : std::make_shared<MessagerOptions>();
  switch (fmt) {
    case Format::kJSON: {
      google::protobuf::util::JsonParseOptions parse_options;
      parse_options.ignore_unknown_fields = options->GetIgnoreUnknownFields();
      auto status = google::protobuf::util::JsonStringToMessage(content, &msg, parse_options);
      if (!status.ok()) {
        SetErrMsg("failed to parse " + msg.GetDescriptor()->name() + kJSONExt + ": " + status.ToString());
        return false;
      }
      return true;
    }
    case Format::kText: {
      if (!google::protobuf::TextFormat::ParseFromString(content, &msg)) {
        SetErrMsg("failed to parse " + msg.GetDescriptor()->name() + kTextExt);
        return false;
      }
      return true;
    }
    case Format::kBin: {
      if (!msg.ParseFromString(content)) {
        SetErrMsg("failed to parse " + msg.GetDescriptor()->name() + kBinExt);
        return false;
      }
      return true;
    }
    default: {
      SetErrMsg("unknown format: " + std::to_string(static_cast<int>(fmt)));
      return false;
    }
  }
}
}  // namespace load
}  // namespace tableau
