// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.10.1
// - protoc                        v3.19.3
// source: test_conf.proto

#pragma once
#include <filesystem>
#include <string>

#include "load.pc.h"
#include "util.pc.h"
#include "test_conf.pb.h"

namespace tableau {
class ActivityConf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::ActivityConf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 private:
  virtual bool ProcessAfterLoad() override final;

 public:
  const protoconf::ActivityConf::Activity* Get(uint64_t activity_id) const;
  const protoconf::ActivityConf::Activity::Chapter* Get(uint64_t activity_id, uint32_t chapter_id) const;
  const protoconf::Section* Get(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id) const;
  const int32_t* Get(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id, uint32_t key4) const;

 private:
  static const std::string kProtoName;
  protoconf::ActivityConf data_;

  // OrderedMap accessers.
 public:
  using OrderedMap_int32Map = std::map<uint32_t, int32_t>;
  const OrderedMap_int32Map* GetOrderedMap(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id) const;

  using OrderedMap_protoconf_SectionValue = std::pair<OrderedMap_int32Map, const protoconf::Section*>;
  using OrderedMap_protoconf_SectionMap = std::map<uint32_t, OrderedMap_protoconf_SectionValue>;
  const OrderedMap_protoconf_SectionMap* GetOrderedMap(uint64_t activity_id, uint32_t chapter_id) const;

  using OrderedMap_Activity_ChapterValue = std::pair<OrderedMap_protoconf_SectionMap, const protoconf::ActivityConf::Activity::Chapter*>;
  using OrderedMap_Activity_ChapterMap = std::map<uint32_t, OrderedMap_Activity_ChapterValue>;
  const OrderedMap_Activity_ChapterMap* GetOrderedMap(uint64_t activity_id) const;

  using OrderedMap_ActivityValue = std::pair<OrderedMap_Activity_ChapterMap, const protoconf::ActivityConf::Activity*>;
  using OrderedMap_ActivityMap = std::map<uint64_t, OrderedMap_ActivityValue>;
  const OrderedMap_ActivityMap* GetOrderedMap() const;

 private:
  OrderedMap_ActivityMap ordered_map_;

  // LeveledIndex keys.
 public:
  struct LeveledIndex_Activity_ChapterKey {
    uint64_t activity_id;
    uint32_t chapter_id;
#if __cplusplus >= 202002L
    bool operator==(const LeveledIndex_Activity_ChapterKey& other) const = default;
#else
    bool operator==(const LeveledIndex_Activity_ChapterKey& other) const {
      return std::tie(activity_id, chapter_id) == std::tie(other.activity_id, other.chapter_id);
    }
#endif
  };
  struct LeveledIndex_Activity_ChapterKeyHasher {
    std::size_t operator()(const LeveledIndex_Activity_ChapterKey& key) const {
      return util::SugaredHashCombine(key.activity_id, key.chapter_id);
    }
  };
  struct LeveledIndex_protoconf_SectionKey {
    uint64_t activity_id;
    uint32_t chapter_id;
    uint32_t section_id;
#if __cplusplus >= 202002L
    bool operator==(const LeveledIndex_protoconf_SectionKey& other) const = default;
#else
    bool operator==(const LeveledIndex_protoconf_SectionKey& other) const {
      return std::tie(activity_id, chapter_id, section_id) == std::tie(other.activity_id, other.chapter_id, other.section_id);
    }
#endif
  };
  struct LeveledIndex_protoconf_SectionKeyHasher {
    std::size_t operator()(const LeveledIndex_protoconf_SectionKey& key) const {
      return util::SugaredHashCombine(key.activity_id, key.chapter_id, key.section_id);
    }
  };

  // Index accessers.
  // Index: ActivityName
 public:
  using Index_ActivityVector = std::vector<const protoconf::ActivityConf::Activity*>;
  using Index_ActivityMap = std::unordered_map<std::string, Index_ActivityVector>;
  // Finds the index (ActivityName) to value (Index_ActivityVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ActivityMap& FindActivityMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_ActivityVector* FindActivity(const std::string& activity_name) const;
  // Finds the first value of the given key(s).
  const protoconf::ActivityConf::Activity* FindFirstActivity(const std::string& activity_name) const;

 private:
  Index_ActivityMap index_activity_map_;

  // Index: ChapterID
 public:
  using Index_ChapterVector = std::vector<const protoconf::ActivityConf::Activity::Chapter*>;
  using Index_ChapterMap = std::unordered_map<uint32_t, Index_ChapterVector>;
  // Finds the index (ChapterID) to value (Index_ChapterVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ChapterMap& FindChapterMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_ChapterVector* FindChapter(uint32_t chapter_id) const;
  // Finds the first value of the given key(s).
  const protoconf::ActivityConf::Activity::Chapter* FindFirstChapter(uint32_t chapter_id) const;
  // Finds the index (ChapterID) to value (Index_ChapterVector) hash map
  // specified by (activity_id).
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_ChapterMap* FindChapterMap(uint64_t activity_id) const;
  // Finds a vector of all values of the given key(s) specified by (activity_id).
  const Index_ChapterVector* FindChapter(uint64_t activity_id, uint32_t chapter_id) const;
  // Finds the first value of the given key(s) specified by (activity_id).
  const protoconf::ActivityConf::Activity::Chapter* FindFirstChapter(uint64_t activity_id, uint32_t chapter_id) const;

 private:
  Index_ChapterMap index_chapter_map_;
  std::unordered_map<uint64_t, Index_ChapterMap> index_chapter_map1_;

  // Index: ChapterName<AwardID>@NamedChapter
 public:
  using Index_NamedChapterVector = std::vector<const protoconf::ActivityConf::Activity::Chapter*>;
  using Index_NamedChapterMap = std::unordered_map<std::string, Index_NamedChapterVector>;
  // Finds the index (ChapterName<AwardID>@NamedChapter) to value (Index_NamedChapterVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_NamedChapterMap& FindNamedChapterMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_NamedChapterVector* FindNamedChapter(const std::string& chapter_name) const;
  // Finds the first value of the given key(s).
  const protoconf::ActivityConf::Activity::Chapter* FindFirstNamedChapter(const std::string& chapter_name) const;
  // Finds the index (ChapterName<AwardID>@NamedChapter) to value (Index_NamedChapterVector) hash map
  // specified by (activity_id).
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_NamedChapterMap* FindNamedChapterMap(uint64_t activity_id) const;
  // Finds a vector of all values of the given key(s) specified by (activity_id).
  const Index_NamedChapterVector* FindNamedChapter(uint64_t activity_id, const std::string& chapter_name) const;
  // Finds the first value of the given key(s) specified by (activity_id).
  const protoconf::ActivityConf::Activity::Chapter* FindFirstNamedChapter(uint64_t activity_id, const std::string& chapter_name) const;

 private:
  Index_NamedChapterMap index_named_chapter_map_;
  std::unordered_map<uint64_t, Index_NamedChapterMap> index_named_chapter_map1_;

  // Index: SectionItemID@Award
 public:
  using Index_AwardVector = std::vector<const protoconf::Section::SectionItem*>;
  using Index_AwardMap = std::unordered_map<uint32_t, Index_AwardVector>;
  // Finds the index (SectionItemID@Award) to value (Index_AwardVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_AwardMap& FindAwardMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_AwardVector* FindAward(uint32_t id) const;
  // Finds the first value of the given key(s).
  const protoconf::Section::SectionItem* FindFirstAward(uint32_t id) const;
  // Finds the index (SectionItemID@Award) to value (Index_AwardVector) hash map
  // specified by (activity_id).
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_AwardMap* FindAwardMap(uint64_t activity_id) const;
  // Finds a vector of all values of the given key(s) specified by (activity_id).
  const Index_AwardVector* FindAward(uint64_t activity_id, uint32_t id) const;
  // Finds the first value of the given key(s) specified by (activity_id).
  const protoconf::Section::SectionItem* FindFirstAward(uint64_t activity_id, uint32_t id) const;
  // Finds the index (SectionItemID@Award) to value (Index_AwardVector) hash map
  // specified by (activity_id, chapter_id).
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_AwardMap* FindAwardMap(uint64_t activity_id, uint32_t chapter_id) const;
  // Finds a vector of all values of the given key(s) specified by (activity_id, chapter_id).
  const Index_AwardVector* FindAward(uint64_t activity_id, uint32_t chapter_id, uint32_t id) const;
  // Finds the first value of the given key(s) specified by (activity_id, chapter_id).
  const protoconf::Section::SectionItem* FindFirstAward(uint64_t activity_id, uint32_t chapter_id, uint32_t id) const;
  // Finds the index (SectionItemID@Award) to value (Index_AwardVector) hash map
  // specified by (activity_id, chapter_id, section_id).
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_AwardMap* FindAwardMap(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id) const;
  // Finds a vector of all values of the given key(s) specified by (activity_id, chapter_id, section_id).
  const Index_AwardVector* FindAward(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id, uint32_t id) const;
  // Finds the first value of the given key(s) specified by (activity_id, chapter_id, section_id).
  const protoconf::Section::SectionItem* FindFirstAward(uint64_t activity_id, uint32_t chapter_id, uint32_t section_id, uint32_t id) const;

 private:
  Index_AwardMap index_award_map_;
  std::unordered_map<uint64_t, Index_AwardMap> index_award_map1_;
  std::unordered_map<LeveledIndex_Activity_ChapterKey, Index_AwardMap, LeveledIndex_Activity_ChapterKeyHasher> index_award_map2_;
  std::unordered_map<LeveledIndex_protoconf_SectionKey, Index_AwardMap, LeveledIndex_protoconf_SectionKeyHasher> index_award_map3_;
};

class ChapterConf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::ChapterConf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 public:
  const protoconf::ChapterConf::Chapter* Get(uint64_t id) const;

 private:
  static const std::string kProtoName;
  protoconf::ChapterConf data_;
};

class ThemeConf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::ThemeConf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 public:
  const protoconf::ThemeConf::Theme* Get(const std::string& name) const;
  const std::string* Get(const std::string& name, const std::string& param) const;

 private:
  static const std::string kProtoName;
  protoconf::ThemeConf data_;
};

class TaskConf : public Messager {
 public:
  static const std::string& Name() { return kProtoName; }
  virtual bool Load(const std::filesystem::path& dir, Format fmt, std::shared_ptr<const load::MessagerOptions> options = nullptr) override;
  const protoconf::TaskConf& Data() const { return data_; }
  const google::protobuf::Message* Message() const override { return &data_; }

 private:
  virtual bool ProcessAfterLoad() override final;

 public:
  const protoconf::TaskConf::Task* Get(int64_t id) const;

 private:
  static const std::string kProtoName;
  protoconf::TaskConf data_;

  // Index accessers.
  // Index: ActivityID<Goal,ID>
 public:
  using Index_TaskVector = std::vector<const protoconf::TaskConf::Task*>;
  using Index_TaskMap = std::unordered_map<int64_t, Index_TaskVector>;
  // Finds the index (ActivityID<Goal,ID>) to value (Index_TaskVector) hash map.
  // One key may correspond to multiple values, which are contained by a vector.
  const Index_TaskMap& FindTaskMap() const;
  // Finds a vector of all values of the given key(s).
  const Index_TaskVector* FindTask(int64_t activity_id) const;
  // Finds the first value of the given key(s).
  const protoconf::TaskConf::Task* FindFirstTask(int64_t activity_id) const;

 private:
  Index_TaskMap index_task_map_;

  // OrderedIndex accessers.
  // OrderedIndex: Goal<ID>@OrderedTask
 public:
  using OrderedIndex_OrderedTaskVector = std::vector<const protoconf::TaskConf::Task*>;
  using OrderedIndex_OrderedTaskMap = std::map<int64_t, OrderedIndex_OrderedTaskVector>;
  // Finds the ordered index (Goal<ID>@OrderedTask) to value (OrderedIndex_OrderedTaskVector) map.
  // One key may correspond to multiple values, which are contained by a vector.
  const OrderedIndex_OrderedTaskMap& FindOrderedTaskMap() const;
  // Finds a vector of all values of the given key(s).
  const OrderedIndex_OrderedTaskVector* FindOrderedTask(int64_t goal) const;
  // Finds the first value of the given key(s).
  const protoconf::TaskConf::Task* FindFirstOrderedTask(int64_t goal) const;

 private:
  OrderedIndex_OrderedTaskMap ordered_index_ordered_task_map_;

  // OrderedIndex: Expiry@TaskExpiry
 public:
  using OrderedIndex_TaskExpiryVector = std::vector<const protoconf::TaskConf::Task*>;
  using OrderedIndex_TaskExpiryMap = std::map<int64_t, OrderedIndex_TaskExpiryVector>;
  // Finds the ordered index (Expiry@TaskExpiry) to value (OrderedIndex_TaskExpiryVector) map.
  // One key may correspond to multiple values, which are contained by a vector.
  const OrderedIndex_TaskExpiryMap& FindTaskExpiryMap() const;
  // Finds a vector of all values of the given key(s).
  const OrderedIndex_TaskExpiryVector* FindTaskExpiry(int64_t expiry) const;
  // Finds the first value of the given key(s).
  const protoconf::TaskConf::Task* FindFirstTaskExpiry(int64_t expiry) const;

 private:
  OrderedIndex_TaskExpiryMap ordered_index_task_expiry_map_;

  // OrderedIndex: Expiry<Goal,ID>@SortedTaskExpiry
 public:
  using OrderedIndex_SortedTaskExpiryVector = std::vector<const protoconf::TaskConf::Task*>;
  using OrderedIndex_SortedTaskExpiryMap = std::map<int64_t, OrderedIndex_SortedTaskExpiryVector>;
  // Finds the ordered index (Expiry<Goal,ID>@SortedTaskExpiry) to value (OrderedIndex_SortedTaskExpiryVector) map.
  // One key may correspond to multiple values, which are contained by a vector.
  const OrderedIndex_SortedTaskExpiryMap& FindSortedTaskExpiryMap() const;
  // Finds a vector of all values of the given key(s).
  const OrderedIndex_SortedTaskExpiryVector* FindSortedTaskExpiry(int64_t expiry) const;
  // Finds the first value of the given key(s).
  const protoconf::TaskConf::Task* FindFirstSortedTaskExpiry(int64_t expiry) const;

 private:
  OrderedIndex_SortedTaskExpiryMap ordered_index_sorted_task_expiry_map_;

  // OrderedIndex: (Expiry,ActivityID)@ActivityExpiry
 public:
  struct OrderedIndex_ActivityExpiryKey {
    int64_t expiry;
    int64_t activity_id;
#if __cplusplus >= 202002L
    auto operator<=>(const OrderedIndex_ActivityExpiryKey& other) const = default;
#else
    bool operator<(const OrderedIndex_ActivityExpiryKey& other) const {
      return std::tie(expiry, activity_id) < std::tie(other.expiry, other.activity_id);
    }
#endif
  };
  using OrderedIndex_ActivityExpiryVector = std::vector<const protoconf::TaskConf::Task*>;
  using OrderedIndex_ActivityExpiryMap = std::map<OrderedIndex_ActivityExpiryKey, OrderedIndex_ActivityExpiryVector>;
  // Finds the ordered index ((Expiry,ActivityID)@ActivityExpiry) to value (OrderedIndex_ActivityExpiryVector) map.
  // One key may correspond to multiple values, which are contained by a vector.
  const OrderedIndex_ActivityExpiryMap& FindActivityExpiryMap() const;
  // Finds a vector of all values of the given key(s).
  const OrderedIndex_ActivityExpiryVector* FindActivityExpiry(int64_t expiry, int64_t activity_id) const;
  // Finds the first value of the given key(s).
  const protoconf::TaskConf::Task* FindFirstActivityExpiry(int64_t expiry, int64_t activity_id) const;

 private:
  OrderedIndex_ActivityExpiryMap ordered_index_activity_expiry_map_;
};

}  // namespace tableau

namespace protoconf {
// Here are some type aliases for easy use.
using ActivityConfMgr = tableau::ActivityConf;
using ChapterConfMgr = tableau::ChapterConf;
using ThemeConfMgr = tableau::ThemeConf;
using TaskConfMgr = tableau::TaskConf;
}  // namespace protoconf
