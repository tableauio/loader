// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.8.0
// - protoc                        v3.19.3

#pragma once
#include <google/protobuf/message.h>

#include <chrono>
#include <functional>
#include <string>

#include "tableau/protobuf/tableau.pb.h"

namespace tableau {
const std::string& GetErrMsg();
void SetErrMsg(const std::string& msg);

#if __cplusplus < 201703L
// Platform-specific path separator
#ifdef _WIN32
constexpr char kPathSeperator = '\\';
#else
constexpr char kPathSeperator = '/';
#endif
#endif

enum class Format {
  kUnknown,
  kJSON,
  kText,
  kBin,
};

static const std::string kEmpty = "";
extern const std::string kUnknownExt;
extern const std::string kJSONExt;
extern const std::string kTextExt;
extern const std::string kBinExt;

struct LoadOptions;

namespace util {
// Combine hash values
//
// References:
//  - https://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x
//  - https://stackoverflow.com/questions/17016175/c-unordered-map-using-a-custom-class-type-as-the-key
inline void HashCombine(std::size_t& seed) {}

template <typename T, typename... O>
inline void HashCombine(std::size_t& seed, const T& v, O... others) {
  std::hash<T> hasher;
  seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
  HashCombine(seed, others...);
}

template <typename T, typename... O>
inline std::size_t SugaredHashCombine(const T& v, O... others) {
  std::size_t seed = 0;  // start with a hash value 0
  HashCombine(seed, v, others...);
  return seed;
}

// Mkdir makes dir recursively.
int Mkdir(const std::string& path);
// GetDir returns all but the last element of path, typically the path's
// directory.
std::string GetDir(const std::string& path);
// ExistsFile checks if a file exists.
bool ExistsFile(const std::string& filename);
// ReadFile reads the file named by filename and returns the contents.
bool ReadFile(const std::string& filename, std::string& content);

// GetExt returns the file name extension used by path.
// The extension is the suffix beginning at the final dot
// in the final element of path; it is empty if there is
// no dot.
std::string GetExt(const std::string& path);
// Convert file extension to Format type.
// NOTE: ext includes dot ".", such as:
//  - kJSONExtï¼š".json"
//  - kTextExt".txt"
//  - kBinExt".bin"
Format Ext2Format(const std::string& ext);
// Empty string will be returned if an unsupported enum value has been passed,
// and the error message can be obtained by GetErrMsg().
const std::string& Format2Ext(Format fmt);

bool JSON2Message(const std::string& json, google::protobuf::Message& msg,
                  std::shared_ptr<const LoadOptions> options = nullptr);
bool Text2Message(const std::string& text, google::protobuf::Message& msg);
bool Bin2Message(const std::string& bin, google::protobuf::Message& msg);

const std::string& GetProtoName(const google::protobuf::Message& msg);
std::string GetPatchName(tableau::Patch patch);

void ProtobufLogHandler(google::protobuf::LogLevel level, const char* filename, int line, const std::string& msg);

class TimeProfiler {
 protected:
  std::chrono::time_point<std::chrono::steady_clock> last_;

 public:
  TimeProfiler() { Start(); }
  void Start() { last_ = std::chrono::steady_clock::now(); }
  // Calculate duration between the last time point and now,
  // and update last time point to now.
  std::chrono::microseconds Elapse() {
    auto now = std::chrono::steady_clock::now();
    auto duration = now - last_;  // This is of type std::chrono::duration
    last_ = now;
    return std::chrono::duration_cast<std::chrono::microseconds>(duration);
  }
};
}  // namespace util
}  // namespace tableau
