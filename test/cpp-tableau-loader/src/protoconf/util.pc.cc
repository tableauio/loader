// Code generated by protoc-gen-cpp-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-cpp-tableau-loader v0.8.0
// - protoc                        v3.19.3

#include "util.pc.h"

#include <google/protobuf/text_format.h>
#include <google/protobuf/util/json_util.h>

#include <filesystem>
#include <fstream>
#include <sstream>
#include <string>

#include "load.pc.h"
#include "logger.pc.h"

namespace tableau {
static thread_local std::string g_err_msg;
const std::string& GetErrMsg() { return g_err_msg; }
void SetErrMsg(const std::string& msg) { g_err_msg = msg; }

const std::string kUnknownExt = ".unknown";
const std::string kJSONExt = ".json";
const std::string kTextExt = ".txt";
const std::string kBinExt = ".bin";

namespace util {
bool ReadFile(const std::string& filename, std::string& content) {
  std::ifstream file(filename);
  if (!file.is_open()) {
    SetErrMsg("failed to open " + filename + ": " + strerror(errno));
    return false;
  }
  content.assign(std::istreambuf_iterator<char>(file), {});
  return true;
}

Format GetFormat(const std::string& path) {
  auto ext = std::filesystem::path(path).extension();
  if (ext == kJSONExt) {
    return Format::kJSON;
  } else if (ext == kTextExt) {
    return Format::kText;
  } else if (ext == kBinExt) {
    return Format::kBin;
  } else {
    return Format::kUnknown;
  }
}

const std::string& Format2Ext(Format fmt) {
  switch (fmt) {
    case Format::kJSON:
      return kJSONExt;
    case Format::kText:
      return kTextExt;
    case Format::kBin:
      return kBinExt;
    default:
      return kUnknownExt;
  }
}

bool JSON2Message(const std::string& json, google::protobuf::Message& msg,
                  std::shared_ptr<const MessagerOptions> options /* = nullptr */) {
  google::protobuf::util::Status status;
  if (options != nullptr) {
    google::protobuf::util::JsonParseOptions parse_options;
    parse_options.ignore_unknown_fields = options->ignore_unknown_fields.value_or(false);
    status = google::protobuf::util::JsonStringToMessage(json, &msg, parse_options);
  } else {
    status = google::protobuf::util::JsonStringToMessage(json, &msg);
  }
  if (!status.ok()) {
    SetErrMsg("failed to parse " + msg.GetDescriptor()->name() + kJSONExt + ": " + status.ToString());
    return false;
  }
  return true;
}

bool Text2Message(const std::string& text, google::protobuf::Message& msg) {
  if (!google::protobuf::TextFormat::ParseFromString(text, &msg)) {
    SetErrMsg("failed to parse " + msg.GetDescriptor()->name() + kTextExt);
    return false;
  }
  return true;
}

bool Bin2Message(const std::string& bin, google::protobuf::Message& msg) {
  if (!msg.ParseFromString(bin)) {
    SetErrMsg("failed to parse " + msg.GetDescriptor()->name() + kBinExt);
    return false;
  }
  return true;
}

// refer: https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/stubs/logging.h
void ProtobufLogHandler(google::protobuf::LogLevel level, const char* filename, int line, const std::string& msg) {
  static const std::unordered_map<int, log::Level> kLevelMap = {{google::protobuf::LOGLEVEL_INFO, log::kInfo},
                                                                {google::protobuf::LOGLEVEL_WARNING, log::kWarn},
                                                                {google::protobuf::LOGLEVEL_ERROR, log::kError},
                                                                {google::protobuf::LOGLEVEL_FATAL, log::kFatal}};
  log::Level lvl = log::kWarn;  // default
  auto iter = kLevelMap.find(level);
  if (iter != kLevelMap.end()) {
    lvl = iter->second;
  }
  ATOM_LOGGER_CALL(tableau::log::DefaultLogger(), lvl, "[libprotobuf %s:%d] %s", filename, line, msg.c_str());
}
}  // namespace util
}  // namespace tableau
