// Code generated by protoc-gen-go-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-go-tableau-loader v0.10.1
// - protoc                       v3.19.3
// source: patch_conf.proto

package loader

import (
	fmt "fmt"
	protoconf "github.com/tableauio/loader/test/go-tableau-loader/protoconf"
	format "github.com/tableauio/tableau/format"
	load "github.com/tableauio/tableau/load"
	store "github.com/tableauio/tableau/store"
	proto "google.golang.org/protobuf/proto"
	time "time"
)

// PatchReplaceConf is a wrapper around protobuf message: protoconf.PatchReplaceConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type PatchReplaceConf struct {
	UnimplementedMessager
	data, originalData *protoconf.PatchReplaceConf
}

// Name returns the PatchReplaceConf's message name.
func (x *PatchReplaceConf) Name() string {
	return string((*protoconf.PatchReplaceConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the PatchReplaceConf's inner message data.
func (x *PatchReplaceConf) Data() *protoconf.PatchReplaceConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load loads PatchReplaceConf's content in the given dir, based on format and messager options.
func (x *PatchReplaceConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.PatchReplaceConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.PatchReplaceConf)
	}
	return x.processAfterLoad()
}

// Store stores PatchReplaceConf's content to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *PatchReplaceConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the PatchReplaceConf's inner message data.
func (x *PatchReplaceConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *PatchReplaceConf) Messager() Messager {
	return x
}

// originalMessage returns the PatchReplaceConf's original inner message.
func (x *PatchReplaceConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// PatchMergeConf is a wrapper around protobuf message: protoconf.PatchMergeConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type PatchMergeConf struct {
	UnimplementedMessager
	data, originalData *protoconf.PatchMergeConf
}

// Name returns the PatchMergeConf's message name.
func (x *PatchMergeConf) Name() string {
	return string((*protoconf.PatchMergeConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the PatchMergeConf's inner message data.
func (x *PatchMergeConf) Data() *protoconf.PatchMergeConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load loads PatchMergeConf's content in the given dir, based on format and messager options.
func (x *PatchMergeConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.PatchMergeConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.PatchMergeConf)
	}
	return x.processAfterLoad()
}

// Store stores PatchMergeConf's content to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *PatchMergeConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the PatchMergeConf's inner message data.
func (x *PatchMergeConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *PatchMergeConf) Messager() Messager {
	return x
}

// originalMessage returns the PatchMergeConf's original inner message.
func (x *PatchMergeConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// Get1 finds value in the 1st-level map. It will return
// NotFound error if the key is not found.
func (x *PatchMergeConf) Get1(id uint32) (*protoconf.Item, error) {
	d := x.Data().GetItemMap()
	if val, ok := d[id]; !ok {
		return nil, fmt.Errorf("id(%v) %w", id, ErrNotFound)
	} else {
		return val, nil
	}
}

// RecursivePatchConf is a wrapper around protobuf message: protoconf.RecursivePatchConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type RecursivePatchConf struct {
	UnimplementedMessager
	data, originalData *protoconf.RecursivePatchConf
}

// Name returns the RecursivePatchConf's message name.
func (x *RecursivePatchConf) Name() string {
	return string((*protoconf.RecursivePatchConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the RecursivePatchConf's inner message data.
func (x *RecursivePatchConf) Data() *protoconf.RecursivePatchConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load loads RecursivePatchConf's content in the given dir, based on format and messager options.
func (x *RecursivePatchConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.RecursivePatchConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.RecursivePatchConf)
	}
	return x.processAfterLoad()
}

// Store stores RecursivePatchConf's content to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *RecursivePatchConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the RecursivePatchConf's inner message data.
func (x *RecursivePatchConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *RecursivePatchConf) Messager() Messager {
	return x
}

// originalMessage returns the RecursivePatchConf's original inner message.
func (x *RecursivePatchConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// Get1 finds value in the 1st-level map. It will return
// NotFound error if the key is not found.
func (x *RecursivePatchConf) Get1(shopId uint32) (*protoconf.RecursivePatchConf_Shop, error) {
	d := x.Data().GetShopMap()
	if val, ok := d[shopId]; !ok {
		return nil, fmt.Errorf("shopId(%v) %w", shopId, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get2 finds value in the 2nd-level map. It will return
// NotFound error if the key is not found.
func (x *RecursivePatchConf) Get2(shopId uint32, goodsId uint32) (*protoconf.RecursivePatchConf_Shop_Goods, error) {
	conf, err := x.Get1(shopId)
	if err != nil {
		return nil, err
	}
	d := conf.GetGoodsMap()
	if val, ok := d[goodsId]; !ok {
		return nil, fmt.Errorf("goodsId(%v) %w", goodsId, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get3 finds value in the 3rd-level map. It will return
// NotFound error if the key is not found.
func (x *RecursivePatchConf) Get3(shopId uint32, goodsId uint32, type_ uint32) (*protoconf.RecursivePatchConf_Shop_Goods_Currency, error) {
	conf, err := x.Get2(shopId, goodsId)
	if err != nil {
		return nil, err
	}
	d := conf.GetCurrencyMap()
	if val, ok := d[type_]; !ok {
		return nil, fmt.Errorf("type_(%v) %w", type_, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get4 finds value in the 4th-level map. It will return
// NotFound error if the key is not found.
func (x *RecursivePatchConf) Get4(shopId uint32, goodsId uint32, type_ uint32, key4 int32) (int32, error) {
	conf, err := x.Get3(shopId, goodsId, type_)
	if err != nil {
		return 0, err
	}
	d := conf.GetValueList()
	if val, ok := d[key4]; !ok {
		return 0, fmt.Errorf("key4(%v) %w", key4, ErrNotFound)
	} else {
		return val, nil
	}
}

func init() {
	Register(func() Messager {
		return new(PatchReplaceConf)
	})
	Register(func() Messager {
		return new(PatchMergeConf)
	})
	Register(func() Messager {
		return new(RecursivePatchConf)
	})
}
