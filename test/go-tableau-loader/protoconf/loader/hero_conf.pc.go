// Code generated by protoc-gen-go-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-go-tableau-loader v0.10.1
// - protoc                       v3.19.3
// source: hero_conf.proto

package loader

import (
	fmt "fmt"
	pair "github.com/tableauio/loader/pkg/pair"
	treemap "github.com/tableauio/loader/pkg/treemap"
	protoconf "github.com/tableauio/loader/test/go-tableau-loader/protoconf"
	base "github.com/tableauio/loader/test/go-tableau-loader/protoconf/base"
	format "github.com/tableauio/tableau/format"
	load "github.com/tableauio/tableau/load"
	store "github.com/tableauio/tableau/store"
	proto "google.golang.org/protobuf/proto"
	time "time"
)

// Index types.
// Index: Title
type Index_HeroConf_AttrMap = map[string][]*protoconf.HeroConf_Hero_Attr

// HeroConf is a wrapper around protobuf message: protoconf.HeroConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type HeroConf struct {
	UnimplementedMessager
	data, originalData *protoconf.HeroConf
	indexAttrMap       Index_HeroConf_AttrMap
}

// Name returns the HeroConf's message name.
func (x *HeroConf) Name() string {
	if x != nil {
		return string(x.data.ProtoReflect().Descriptor().Name())
	}
	return ""
}

// Data returns the HeroConf's inner message data.
func (x *HeroConf) Data() *protoconf.HeroConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills HeroConf's inner message from file in the specified directory and format.
func (x *HeroConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.HeroConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.HeroConf)
	}
	return x.processAfterLoad()
}

// Store writes HeroConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *HeroConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the HeroConf's inner message data.
func (x *HeroConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *HeroConf) Messager() Messager {
	return x
}

// originalMessage returns the HeroConf's original inner message.
func (x *HeroConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// processAfterLoad runs after this messager is loaded.
func (x *HeroConf) processAfterLoad() error {
	// Index init.
	x.indexAttrMap = make(Index_HeroConf_AttrMap)
	for _, item1 := range x.data.GetHeroMap() {
		for _, item2 := range item1.GetAttrMap() {
			{
				// Index: Title
				key := item2.GetTitle()
				x.indexAttrMap[key] = append(x.indexAttrMap[key], item2)
			}
		}
	}
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *HeroConf) Get1(name string) (*protoconf.HeroConf_Hero, error) {
	d := x.Data().GetHeroMap()
	if val, ok := d[name]; !ok {
		return nil, fmt.Errorf("name(%v) %w", name, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get2 finds value in the 2-level map. It will return
// NotFound error if the key is not found.
func (x *HeroConf) Get2(name string, title string) (*protoconf.HeroConf_Hero_Attr, error) {
	conf, err := x.Get1(name)
	if err != nil {
		return nil, err
	}
	d := conf.GetAttrMap()
	if val, ok := d[title]; !ok {
		return nil, fmt.Errorf("title(%v) %w", title, ErrNotFound)
	} else {
		return val, nil
	}
}

// Index: Title

// FindAttrMap finds the index (Title) to value (protoconf.HeroConf_Hero_Attr) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *HeroConf) FindAttrMap() Index_HeroConf_AttrMap {
	return x.indexAttrMap
}

// FindAttr finds a slice of all values of the given key.
func (x *HeroConf) FindAttr(title string) []*protoconf.HeroConf_Hero_Attr {
	return x.indexAttrMap[title]
}

// FindFirstAttr finds the first value of the given key,
// or nil if no value found.
func (x *HeroConf) FindFirstAttr(title string) *protoconf.HeroConf_Hero_Attr {
	val := x.FindAttr(title)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedMap types.
type OrderedMap_HeroBaseConf_base_ItemMap = treemap.TreeMap[string, *base.Item]

type OrderedMap_HeroBaseConf_base_HeroValue = pair.Pair[*OrderedMap_HeroBaseConf_base_ItemMap, *base.Hero]
type OrderedMap_HeroBaseConf_base_HeroMap = treemap.TreeMap[string, *OrderedMap_HeroBaseConf_base_HeroValue]

// HeroBaseConf is a wrapper around protobuf message: protoconf.HeroBaseConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type HeroBaseConf struct {
	UnimplementedMessager
	data, originalData *protoconf.HeroBaseConf
	orderedMap         *OrderedMap_HeroBaseConf_base_HeroMap
}

// Name returns the HeroBaseConf's message name.
func (x *HeroBaseConf) Name() string {
	if x != nil {
		return string(x.data.ProtoReflect().Descriptor().Name())
	}
	return ""
}

// Data returns the HeroBaseConf's inner message data.
func (x *HeroBaseConf) Data() *protoconf.HeroBaseConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills HeroBaseConf's inner message from file in the specified directory and format.
func (x *HeroBaseConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.HeroBaseConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.HeroBaseConf)
	}
	return x.processAfterLoad()
}

// Store writes HeroBaseConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *HeroBaseConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the HeroBaseConf's inner message data.
func (x *HeroBaseConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *HeroBaseConf) Messager() Messager {
	return x
}

// originalMessage returns the HeroBaseConf's original inner message.
func (x *HeroBaseConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// processAfterLoad runs after this messager is loaded.
func (x *HeroBaseConf) processAfterLoad() error {
	// OrderedMap init.
	x.orderedMap = treemap.New[string, *OrderedMap_HeroBaseConf_base_HeroValue]()
	for k1, v1 := range x.Data().GetHeroMap() {
		map1 := x.orderedMap
		k1v := &OrderedMap_HeroBaseConf_base_HeroValue{
			First:  treemap.New[string, *base.Item](),
			Second: v1,
		}
		map1.Put(k1, k1v)
		for k2, v2 := range v1.GetItemMap() {
			map2 := k1v.First
			map2.Put(k2, v2)
		}
	}
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *HeroBaseConf) Get1(name string) (*base.Hero, error) {
	d := x.Data().GetHeroMap()
	if val, ok := d[name]; !ok {
		return nil, fmt.Errorf("name(%v) %w", name, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get2 finds value in the 2-level map. It will return
// NotFound error if the key is not found.
func (x *HeroBaseConf) Get2(name string, id string) (*base.Item, error) {
	conf, err := x.Get1(name)
	if err != nil {
		return nil, err
	}
	d := conf.GetItemMap()
	if val, ok := d[id]; !ok {
		return nil, fmt.Errorf("id(%v) %w", id, ErrNotFound)
	} else {
		return val, nil
	}
}

// GetOrderedMap returns the 1-level ordered map.
func (x *HeroBaseConf) GetOrderedMap() *OrderedMap_HeroBaseConf_base_HeroMap {
	return x.orderedMap
}

// GetOrderedMap1 finds value in the 1-level ordered map. It will return
// NotFound error if the key is not found.
func (x *HeroBaseConf) GetOrderedMap1(name string) (*OrderedMap_HeroBaseConf_base_ItemMap, error) {
	conf := x.orderedMap
	if val, ok := conf.Get(name); !ok {
		return nil, fmt.Errorf("name(%v) %w", name, ErrNotFound)
	} else {
		return val.First, nil
	}
}

func init() {
	Register(func() Messager {
		return new(HeroConf)
	})
	Register(func() Messager {
		return new(HeroBaseConf)
	})
}
