// Code generated by protoc-gen-go-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-go-tableau-loader v0.10.0
// - protoc                       v3.19.3

package loader

import (
	"fmt"
	"os"
	"time"

	"github.com/pkg/errors"
	"github.com/pmezard/go-difflib/difflib"
	"github.com/tableauio/tableau/format"
	"github.com/tableauio/tableau/store"
	"google.golang.org/protobuf/proto"
)

type Options struct {
	// Filter can only filter in certain specific messagers based on the
	// condition that you provide.
	//
	// Default: nil.
	Filter FilterFunc

	// MutableCheck enables the mutable check of the loaded config,
	// and specifies its interval and mutable handler.
	//
	// Default: nil.
	MutableCheck *MutableCheck
}

// FilterFunc filter in messagers if returned value is true.
//
// NOTE: name is the protobuf message name, e.g.: "message ItemConf{...}".
type FilterFunc func(name string) bool

type MutableCheck struct {
	// Interval is the gap duration between two checks.
	// Default: 60s.
	Interval time.Duration
	// OnMutate is called when encouters mutations, with messager's name,
	// original message and current message.
	OnMutate func(name string, original, current proto.Message)
}

// Option is the functional option type.
type Option func(*Options)

// newDefault returns a default Options.
func newDefault() *Options {
	return &Options{}
}

// ParseOptions parses functional options and merge them to default Options.
func ParseOptions(setters ...Option) *Options {
	// Default Options
	opts := newDefault()
	for _, setter := range setters {
		setter(opts)
	}
	return opts
}

// Filter can only filter in certain specific messagers based on the
// condition that you provide.
func Filter(filter FilterFunc) Option {
	return func(opts *Options) {
		opts.Filter = filter
	}
}

// WithMutableCheck enables the mutable check with given params.
func WithMutableCheck(check *MutableCheck) Option {
	return func(opts *Options) {
		opts.MutableCheck = check
	}
}

// Hub is the messager manager.
type Hub struct {
	opts     *Options
	provider messagerContainerProvider
}

func newHub(provider messagerContainerProvider, options ...Option) *Hub {
	hub := &Hub{}
	hub.opts = ParseOptions(options...)
	hub.provider = provider
	if hub.opts.MutableCheck != nil {
		go hub.mutableCheck()
	}
	return hub
}

// providedBy returns a new Hub with the specified provider.
func (h *Hub) providedBy(provider messagerContainerProvider) *Hub {
	return &Hub{
		opts:     h.opts,
		provider: provider,
	}
}

// NewMessagerMap creates a new MessagerMap.
func (h *Hub) NewMessagerMap() MessagerMap {
	messagerMap := MessagerMap{}
	for name, gen := range getRegistrar().Generators {
		if h.opts.Filter == nil || h.opts.Filter(name) {
			messager := gen()
			if h.opts.MutableCheck != nil {
				messager.enableBackup()
			}
			messagerMap[name] = messager
		}
	}
	return messagerMap
}

// getMessagerContainer returns hub's inner messager container.
func (h *Hub) getMessagerContainer() *messagerContainer {
	return h.provider.MessagerContainer()
}

// GetMessagerMap returns hub's inner field messagerMap.
func (h *Hub) GetMessagerMap() MessagerMap {
	return h.getMessagerContainer().messagerMap
}

// GetMessager finds and returns the specified Messenger in hub.
func (h *Hub) GetMessager(name string) Messager {
	return h.GetMessagerMap()[name]
}

// Store stores protobuf messages to files in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (h *Hub) Store(dir string, format format.Format, options ...store.Option) error {
	opts := store.ParseOptions(options...)
	for name, msger := range h.GetMessagerMap() {
		if opts.Filter == nil || opts.Filter(name) {
			if err := msger.Store(dir, format, options...); err != nil {
				return errors.WithMessagef(err, "failed to store: %v", name)
			}
		}
	}
	return nil
}

// mutableCheck checks if the messagers are mutable or not.
func (h *Hub) mutableCheck() {
	interval := h.opts.MutableCheck.Interval
	if interval == 0 {
		interval = time.Minute
	}
	handler := h.opts.MutableCheck.OnMutate
	if handler == nil {
		handler = h.onMutateDefault
	}
	for {
		time.Sleep(interval)
		messagerMap := h.GetMessagerMap()
		for name, msger := range messagerMap {
			time.Sleep(time.Second)
			if !proto.Equal(msger.originalMessage(), msger.Message()) {
				handler(name, msger.originalMessage(), msger.Message())
			}
		}
	}
}

func (h *Hub) onMutateDefault(name string, original, current proto.Message) {
	originalText, _ := store.MarshalToText(original, true)
	currentText, _ := store.MarshalToText(current, true)
	diff := difflib.UnifiedDiff{
		A:        difflib.SplitLines(string(originalText)),
		B:        difflib.SplitLines(string(currentText)),
		FromFile: "Original",
		ToFile:   "Current",
		Context:  3,
	}
	text, _ := difflib.GetUnifiedDiffString(diff)
	fmt.Fprintf(os.Stderr,
		"==== %s DIFF BEGIN ====\n%s==== %s DIFF END ====\n",
		name, text, name)
}

// GetLastLoadedTime returns the time when hub's messagerMap was last set.
func (h *Hub) GetLastLoadedTime() time.Time {
	return h.getMessagerContainer().loadedTime
}

// Auto-generated getters below

func (h *Hub) GetHeroConf() *HeroConf {
	return h.getMessagerContainer().heroConf
}

func (h *Hub) GetHeroBaseConf() *HeroBaseConf {
	return h.getMessagerContainer().heroBaseConf
}

func (h *Hub) GetItemConf() *ItemConf {
	return h.getMessagerContainer().itemConf
}

func (h *Hub) GetPatchReplaceConf() *PatchReplaceConf {
	return h.getMessagerContainer().patchReplaceConf
}

func (h *Hub) GetPatchMergeConf() *PatchMergeConf {
	return h.getMessagerContainer().patchMergeConf
}

func (h *Hub) GetRecursivePatchConf() *RecursivePatchConf {
	return h.getMessagerContainer().recursivePatchConf
}

func (h *Hub) GetActivityConf() *ActivityConf {
	return h.getMessagerContainer().activityConf
}

func (h *Hub) GetChapterConf() *ChapterConf {
	return h.getMessagerContainer().chapterConf
}

func (h *Hub) GetThemeConf() *ThemeConf {
	return h.getMessagerContainer().themeConf
}

func (h *Hub) GetTaskConf() *TaskConf {
	return h.getMessagerContainer().taskConf
}

type messagerContainer struct {
	messagerMap MessagerMap
	loadedTime  time.Time
	// all messagers as fields for fast access
	heroConf           *HeroConf
	heroBaseConf       *HeroBaseConf
	itemConf           *ItemConf
	patchReplaceConf   *PatchReplaceConf
	patchMergeConf     *PatchMergeConf
	recursivePatchConf *RecursivePatchConf
	activityConf       *ActivityConf
	chapterConf        *ChapterConf
	themeConf          *ThemeConf
	taskConf           *TaskConf
}

func newMessagerContainer(messagerMap MessagerMap) *messagerContainer {
	messagerContainer := &messagerContainer{
		messagerMap: messagerMap,
		loadedTime:  time.Now(),
	}
	messagerContainer.heroConf, _ = messagerMap[(&HeroConf{}).Name()].(*HeroConf)
	messagerContainer.heroBaseConf, _ = messagerMap[(&HeroBaseConf{}).Name()].(*HeroBaseConf)
	messagerContainer.itemConf, _ = messagerMap[(&ItemConf{}).Name()].(*ItemConf)
	messagerContainer.patchReplaceConf, _ = messagerMap[(&PatchReplaceConf{}).Name()].(*PatchReplaceConf)
	messagerContainer.patchMergeConf, _ = messagerMap[(&PatchMergeConf{}).Name()].(*PatchMergeConf)
	messagerContainer.recursivePatchConf, _ = messagerMap[(&RecursivePatchConf{}).Name()].(*RecursivePatchConf)
	messagerContainer.activityConf, _ = messagerMap[(&ActivityConf{}).Name()].(*ActivityConf)
	messagerContainer.chapterConf, _ = messagerMap[(&ChapterConf{}).Name()].(*ChapterConf)
	messagerContainer.themeConf, _ = messagerMap[(&ThemeConf{}).Name()].(*ThemeConf)
	messagerContainer.taskConf, _ = messagerMap[(&TaskConf{}).Name()].(*TaskConf)
	return messagerContainer
}
