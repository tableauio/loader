// Code generated by protoc-gen-go-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-go-tableau-loader v0.10.1
// - protoc                       v3.19.3

package loader

import (
	"context"
	"fmt"
	"os"
	"sync/atomic"
	"time"

	"github.com/pkg/errors"
	"github.com/tableauio/tableau/format"
	"github.com/tableauio/tableau/load"
	"github.com/tableauio/tableau/store"
	"google.golang.org/protobuf/proto"
)

type Options struct {
	// Filter can only filter in certain specific messagers based on the
	// condition that you provide.
	//
	// Default: nil.
	Filter FilterFunc

	// MutableCheck enables the mutable check of the loaded config,
	// and specifies its interval and mutable handler.
	//
	// Default: nil.
	MutableCheck *MutableCheck
}

// FilterFunc filter in messagers if returned value is true.
//
// NOTE: name is the protobuf message name, e.g.: "message ItemConf{...}".
type FilterFunc func(name string) bool

type MutableCheck struct {
	// Interval is the gap duration between two checks.
	// Default: 60s.
	Interval time.Duration
	// OnMutate is called when encouters mutations, with messager's name,
	// original message and current message.
	OnMutate func(name string, original, current proto.Message)
}

// Option is the functional option type.
type Option func(*Options)

// newDefault returns a default Options.
func newDefault() *Options {
	return &Options{}
}

// ParseOptions parses functional options and merge them to default Options.
func ParseOptions(setters ...Option) *Options {
	// Default Options
	opts := newDefault()
	for _, setter := range setters {
		setter(opts)
	}
	return opts
}

// Filter can only filter in certain specific messagers based on the
// condition that you provide.
func Filter(filter FilterFunc) Option {
	return func(opts *Options) {
		opts.Filter = filter
	}
}

// WithMutableCheck enables the mutable check with given params.
func WithMutableCheck(check *MutableCheck) Option {
	return func(opts *Options) {
		opts.MutableCheck = check
	}
}

// Hub is the messager manager.
type Hub struct {
	mc   atomic.Pointer[MessagerContainer]
	opts *Options
}

func NewHub(options ...Option) *Hub {
	hub := &Hub{}
	hub.mc.Store(&MessagerContainer{})
	hub.opts = ParseOptions(options...)
	if hub.opts.MutableCheck != nil {
		go hub.mutableCheck()
	}
	return hub
}

// NewMessagerMap creates a new MessagerMap.
func (h *Hub) NewMessagerMap() MessagerMap {
	messagerMap := MessagerMap{}
	for name, gen := range getRegistrar().Generators {
		if h.opts.Filter == nil || h.opts.Filter(name) {
			messager := gen()
			if h.opts.MutableCheck != nil {
				messager.enableBackup()
			}
			messagerMap[name] = messager
		}
	}
	return messagerMap
}

func (h *Hub) SetMessagerMap(messagerMap MessagerMap) {
	h.mc.Store(newMessagerContainer(messagerMap))
}

// Load fills messages from files in the specified directory and format.
func (h *Hub) Load(dir string, format format.Format, options ...load.Option) error {
	messagerMap := h.NewMessagerMap()
	opts := load.ParseOptions(options...)
	for name, msger := range messagerMap {
		mopts := opts.ParseMessagerOptionsByName(name)
		if err := msger.Load(dir, format, mopts); err != nil {
			return errors.WithMessagef(err, "failed to load: %v", name)
		}
	}
	// create a temporary hub with messager container for post process
	tmpHub := &Hub{}
	tmpHub.SetMessagerMap(messagerMap)
	for name, msger := range messagerMap {
		if err := msger.ProcessAfterLoadAll(tmpHub); err != nil {
			return errors.WithMessagef(err, "failed to process messager %s after load all", name)
		}
	}
	h.SetMessagerMap(messagerMap)
	return nil
}

// Store stores protobuf messages to files in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (h *Hub) Store(dir string, format format.Format, options ...store.Option) error {
	opts := store.ParseOptions(options...)
	for name, msger := range h.GetMessagerMap() {
		if opts.Filter == nil || opts.Filter(name) {
			if err := msger.Store(dir, format, options...); err != nil {
				return errors.WithMessagef(err, "failed to store: %v", name)
			}
		}
	}
	return nil
}

// mutableCheck checks if the messagers are mutable or not.
func (h *Hub) mutableCheck() {
	interval := h.opts.MutableCheck.Interval
	if interval == 0 {
		interval = time.Minute
	}
	handler := h.opts.MutableCheck.OnMutate
	if handler == nil {
		handler = h.onMutateDefault
	}
	for {
		time.Sleep(interval)
		messagerMap := h.GetMessagerMap()
		for name, msger := range messagerMap {
			time.Sleep(time.Second)
			if !proto.Equal(msger.originalMessage(), msger.Message()) {
				handler(name, msger.originalMessage(), msger.Message())
			}
		}
	}
}

func (h *Hub) onMutateDefault(name string, original, current proto.Message) {
	text, _ := UnifiedDiff(original, current)
	fmt.Fprintf(os.Stderr,
		"==== %s DIFF BEGIN ====\n%s==== %s DIFF END ====\n",
		name, text, name)
}

type ctxKey struct{}

// NewContext creates a derived context which binds the current underlying
// [MessagerContainer].
func (h *Hub) NewContext(ctx context.Context) context.Context {
	return context.WithValue(ctx, ctxKey{}, h.mc.Load())
}

// FromContext returns the [MessagerContainer] associated with this context,
// or the default [MessagerContainer] if this context has no associated one.
func (h *Hub) FromContext(ctx context.Context) *MessagerContainer {
	mc, ok := ctx.Value(ctxKey{}).(*MessagerContainer)
	if ok {
		return mc
	}
	return h.mc.Load()
}

// Export MessagerContainer methods below.

func (h *Hub) GetMessagerMap() MessagerMap {
	return h.mc.Load().GetMessagerMap()
}

func (h *Hub) GetMessager(name string) Messager {
	return h.mc.Load().GetMessager(name)
}

func (h *Hub) GetLastLoadedTime() time.Time {
	return h.mc.Load().GetLastLoadedTime()
}

func (h *Hub) GetHeroConf() *HeroConf {
	return h.mc.Load().GetHeroConf()
}

func (h *Hub) GetHeroBaseConf() *HeroBaseConf {
	return h.mc.Load().GetHeroBaseConf()
}

func (h *Hub) GetItemConf() *ItemConf {
	return h.mc.Load().GetItemConf()
}

func (h *Hub) GetFruitConf() *FruitConf {
	return h.mc.Load().GetFruitConf()
}

func (h *Hub) GetFruit2Conf() *Fruit2Conf {
	return h.mc.Load().GetFruit2Conf()
}

func (h *Hub) GetPatchReplaceConf() *PatchReplaceConf {
	return h.mc.Load().GetPatchReplaceConf()
}

func (h *Hub) GetPatchMergeConf() *PatchMergeConf {
	return h.mc.Load().GetPatchMergeConf()
}

func (h *Hub) GetRecursivePatchConf() *RecursivePatchConf {
	return h.mc.Load().GetRecursivePatchConf()
}

func (h *Hub) GetActivityConf() *ActivityConf {
	return h.mc.Load().GetActivityConf()
}

func (h *Hub) GetChapterConf() *ChapterConf {
	return h.mc.Load().GetChapterConf()
}

func (h *Hub) GetThemeConf() *ThemeConf {
	return h.mc.Load().GetThemeConf()
}

func (h *Hub) GetTaskConf() *TaskConf {
	return h.mc.Load().GetTaskConf()
}
