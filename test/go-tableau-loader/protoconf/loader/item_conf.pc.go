// Code generated by protoc-gen-go-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-go-tableau-loader v0.10.1
// - protoc                       v3.19.3
// source: item_conf.proto

package loader

import (
	fmt "fmt"
	treemap "github.com/tableauio/loader/pkg/treemap"
	protoconf "github.com/tableauio/loader/test/go-tableau-loader/protoconf"
	format "github.com/tableauio/tableau/format"
	load "github.com/tableauio/tableau/load"
	store "github.com/tableauio/tableau/store"
	proto "google.golang.org/protobuf/proto"
	sort "sort"
	time "time"
)

// OrderedMap types.
type ItemConf_OrderedMap_ItemMap = treemap.TreeMap[uint32, *protoconf.ItemConf_Item]

// Index types.
// Index: Type
type ItemConf_Index_ItemMap = map[protoconf.FruitType][]*protoconf.ItemConf_Item

// Index: Param<ID>@ItemInfo
type ItemConf_Index_ItemInfoMap = map[int32][]*protoconf.ItemConf_Item

// Index: Default@ItemDefaultInfo
type ItemConf_Index_ItemDefaultInfoMap = map[string][]*protoconf.ItemConf_Item

// Index: ExtType@ItemExtInfo
type ItemConf_Index_ItemExtInfoMap = map[protoconf.FruitType][]*protoconf.ItemConf_Item

// Index: (ID,Name)<Type,UseEffectType>@AwardItem
type ItemConf_Index_AwardItemKey struct {
	Id   uint32
	Name string
}
type ItemConf_Index_AwardItemMap = map[ItemConf_Index_AwardItemKey][]*protoconf.ItemConf_Item

// Index: (ID,Type,Param,ExtType)@SpecialItem
type ItemConf_Index_SpecialItemKey struct {
	Id      uint32
	Type    protoconf.FruitType
	Param   int32
	ExtType protoconf.FruitType
}
type ItemConf_Index_SpecialItemMap = map[ItemConf_Index_SpecialItemKey][]*protoconf.ItemConf_Item

// Index: PathDir@ItemPathDir
type ItemConf_Index_ItemPathDirMap = map[string][]*protoconf.ItemConf_Item

// Index: PathName@ItemPathName
type ItemConf_Index_ItemPathNameMap = map[string][]*protoconf.ItemConf_Item

// Index: PathFriendID@ItemPathFriendID
type ItemConf_Index_ItemPathFriendIDMap = map[uint32][]*protoconf.ItemConf_Item

// Index: UseEffectType@UseEffectType
type ItemConf_Index_UseEffectTypeMap = map[protoconf.UseEffect_Type][]*protoconf.ItemConf_Item

// OrderedIndex types.
// OrderedIndex: ExtType@ExtType
type ItemConf_OrderedIndex_ExtTypeMap = treemap.TreeMap[protoconf.FruitType, []*protoconf.ItemConf_Item]

// OrderedIndex: (Param,ExtType)<ID>@ParamExtType
type ItemConf_OrderedIndex_ParamExtTypeKey struct {
	Param   int32
	ExtType protoconf.FruitType
}

func (x ItemConf_OrderedIndex_ParamExtTypeKey) Less(other ItemConf_OrderedIndex_ParamExtTypeKey) bool {
	if x.Param != other.Param {
		return x.Param < other.Param
	}
	return x.ExtType < other.ExtType
}

type ItemConf_OrderedIndex_ParamExtTypeMap = treemap.TreeMap[ItemConf_OrderedIndex_ParamExtTypeKey, []*protoconf.ItemConf_Item]

// ItemConf is a wrapper around protobuf message: protoconf.ItemConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type ItemConf struct {
	UnimplementedMessager
	data, originalData          *protoconf.ItemConf
	orderedMap                  *ItemConf_OrderedMap_ItemMap
	indexItemMap                ItemConf_Index_ItemMap
	indexItemInfoMap            ItemConf_Index_ItemInfoMap
	indexItemDefaultInfoMap     ItemConf_Index_ItemDefaultInfoMap
	indexItemExtInfoMap         ItemConf_Index_ItemExtInfoMap
	indexAwardItemMap           ItemConf_Index_AwardItemMap
	indexSpecialItemMap         ItemConf_Index_SpecialItemMap
	indexItemPathDirMap         ItemConf_Index_ItemPathDirMap
	indexItemPathNameMap        ItemConf_Index_ItemPathNameMap
	indexItemPathFriendIdMap    ItemConf_Index_ItemPathFriendIDMap
	indexUseEffectTypeMap       ItemConf_Index_UseEffectTypeMap
	orderedIndexExtTypeMap      *ItemConf_OrderedIndex_ExtTypeMap
	orderedIndexParamExtTypeMap *ItemConf_OrderedIndex_ParamExtTypeMap
}

// Name returns the ItemConf's message name.
func (x *ItemConf) Name() string {
	return string((*protoconf.ItemConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the ItemConf's inner message data.
func (x *ItemConf) Data() *protoconf.ItemConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills ItemConf's inner message from file in the specified directory and format.
func (x *ItemConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.ItemConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.ItemConf)
	}
	return x.processAfterLoad()
}

// Store writes ItemConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *ItemConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the ItemConf's inner message data.
func (x *ItemConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *ItemConf) Messager() Messager {
	return x
}

// originalMessage returns the ItemConf's original inner message.
func (x *ItemConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// processAfterLoad runs after this messager is loaded.
func (x *ItemConf) processAfterLoad() error {
	// OrderedMap init.
	x.orderedMap = treemap.New[uint32, *protoconf.ItemConf_Item]()
	for k1, v1 := range x.Data().GetItemMap() {
		map1 := x.orderedMap
		map1.Put(k1, v1)
	}
	// Index init.
	x.indexItemMap = make(ItemConf_Index_ItemMap)
	x.indexItemInfoMap = make(ItemConf_Index_ItemInfoMap)
	x.indexItemDefaultInfoMap = make(ItemConf_Index_ItemDefaultInfoMap)
	x.indexItemExtInfoMap = make(ItemConf_Index_ItemExtInfoMap)
	x.indexAwardItemMap = make(ItemConf_Index_AwardItemMap)
	x.indexSpecialItemMap = make(ItemConf_Index_SpecialItemMap)
	x.indexItemPathDirMap = make(ItemConf_Index_ItemPathDirMap)
	x.indexItemPathNameMap = make(ItemConf_Index_ItemPathNameMap)
	x.indexItemPathFriendIdMap = make(ItemConf_Index_ItemPathFriendIDMap)
	x.indexUseEffectTypeMap = make(ItemConf_Index_UseEffectTypeMap)
	for k1, v1 := range x.data.GetItemMap() {
		_ = k1
		{
			// Index: Type
			key := v1.GetType()
			x.indexItemMap[key] = append(x.indexItemMap[key], v1)
		}
		{
			// Index: Param<ID>@ItemInfo
			for k2, v2 := range v1.GetParamList() {
				_ = k2
				key := v2
				x.indexItemInfoMap[key] = append(x.indexItemInfoMap[key], v1)
			}
		}
		{
			// Index: Default@ItemDefaultInfo
			key := v1.GetDefault()
			x.indexItemDefaultInfoMap[key] = append(x.indexItemDefaultInfoMap[key], v1)
		}
		{
			// Index: ExtType@ItemExtInfo
			for k2, v2 := range v1.GetExtTypeList() {
				_ = k2
				key := v2
				x.indexItemExtInfoMap[key] = append(x.indexItemExtInfoMap[key], v1)
			}
		}
		{
			// Index: (ID,Name)<Type,UseEffectType>@AwardItem
			key := ItemConf_Index_AwardItemKey{v1.GetId(), v1.GetName()}
			x.indexAwardItemMap[key] = append(x.indexAwardItemMap[key], v1)
		}
		{
			// Index: (ID,Type,Param,ExtType)@SpecialItem
			for _, indexItem2 := range v1.GetParamList() {
				for _, indexItem3 := range v1.GetExtTypeList() {
					key := ItemConf_Index_SpecialItemKey{v1.GetId(), v1.GetType(), indexItem2, indexItem3}
					x.indexSpecialItemMap[key] = append(x.indexSpecialItemMap[key], v1)
				}
			}
		}
		{
			// Index: PathDir@ItemPathDir
			key := v1.GetPath().GetDir()
			x.indexItemPathDirMap[key] = append(x.indexItemPathDirMap[key], v1)
		}
		{
			// Index: PathName@ItemPathName
			for k2, v2 := range v1.GetPath().GetNameList() {
				_ = k2
				key := v2
				x.indexItemPathNameMap[key] = append(x.indexItemPathNameMap[key], v1)
			}
		}
		{
			// Index: PathFriendID@ItemPathFriendID
			key := v1.GetPath().GetFriend().GetId()
			x.indexItemPathFriendIdMap[key] = append(x.indexItemPathFriendIdMap[key], v1)
		}
		{
			// Index: UseEffectType@UseEffectType
			key := v1.GetUseEffect().GetType()
			x.indexUseEffectTypeMap[key] = append(x.indexUseEffectTypeMap[key], v1)
		}
	}
	// Index(sort): Param<ID>@ItemInfo
	indexItemInfoMapSorter := func(item []*protoconf.ItemConf_Item) func(i, j int) bool {
		return func(i, j int) bool {
			return item[i].GetId() < item[j].GetId()
		}
	}
	for _, item := range x.indexItemInfoMap {
		sort.Slice(item, indexItemInfoMapSorter(item))
	}
	// Index(sort): (ID,Name)<Type,UseEffectType>@AwardItem
	indexAwardItemMapSorter := func(item []*protoconf.ItemConf_Item) func(i, j int) bool {
		return func(i, j int) bool {
			if item[i].GetType() != item[j].GetType() {
				return item[i].GetType() < item[j].GetType()
			}
			return item[i].GetUseEffect().GetType() < item[j].GetUseEffect().GetType()
		}
	}
	for _, item := range x.indexAwardItemMap {
		sort.Slice(item, indexAwardItemMapSorter(item))
	}
	// OrderedIndex init.
	x.orderedIndexExtTypeMap = treemap.New[protoconf.FruitType, []*protoconf.ItemConf_Item]()
	x.orderedIndexParamExtTypeMap = treemap.New2[ItemConf_OrderedIndex_ParamExtTypeKey, []*protoconf.ItemConf_Item]()
	for k1, v1 := range x.data.GetItemMap() {
		_ = k1
		{
			// OrderedIndex: ExtType@ExtType
			for k2, v2 := range v1.GetExtTypeList() {
				_ = k2
				key := v2
				value, _ := x.orderedIndexExtTypeMap.Get(key)
				x.orderedIndexExtTypeMap.Put(key, append(value, v1))
			}
		}
		{
			// OrderedIndex: (Param,ExtType)<ID>@ParamExtType
			for _, indexItem0 := range v1.GetParamList() {
				for _, indexItem1 := range v1.GetExtTypeList() {
					key := ItemConf_OrderedIndex_ParamExtTypeKey{indexItem0, indexItem1}
					value, _ := x.orderedIndexParamExtTypeMap.Get(key)
					x.orderedIndexParamExtTypeMap.Put(key, append(value, v1))
				}
			}
		}
	}
	// OrderedIndex(sort): (Param,ExtType)<ID>@ParamExtType
	orderedIndexParamExtTypeMapSorter := func(item []*protoconf.ItemConf_Item) func(i, j int) bool {
		return func(i, j int) bool {
			return item[i].GetId() < item[j].GetId()
		}
	}
	x.orderedIndexParamExtTypeMap.Range(func(key ItemConf_OrderedIndex_ParamExtTypeKey, item []*protoconf.ItemConf_Item) bool {
		sort.Slice(item, orderedIndexParamExtTypeMapSorter(item))
		return true
	})
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *ItemConf) Get1(id uint32) (*protoconf.ItemConf_Item, error) {
	d := x.Data().GetItemMap()
	if val, ok := d[id]; !ok {
		return nil, fmt.Errorf("id(%v) %w", id, ErrNotFound)
	} else {
		return val, nil
	}
}

// GetOrderedMap returns the 1-level ordered map.
func (x *ItemConf) GetOrderedMap() *ItemConf_OrderedMap_ItemMap {
	return x.orderedMap
}

// Index: Type

// FindItemMap finds the index (Type) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindItemMap() ItemConf_Index_ItemMap {
	return x.indexItemMap
}

// FindItem finds a slice of all values of the given key.
func (x *ItemConf) FindItem(type_ protoconf.FruitType) []*protoconf.ItemConf_Item {
	return x.indexItemMap[type_]
}

// FindFirstItem finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstItem(type_ protoconf.FruitType) *protoconf.ItemConf_Item {
	val := x.FindItem(type_)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: Param<ID>@ItemInfo

// FindItemInfoMap finds the index (Param<ID>@ItemInfo) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindItemInfoMap() ItemConf_Index_ItemInfoMap {
	return x.indexItemInfoMap
}

// FindItemInfo finds a slice of all values of the given key.
func (x *ItemConf) FindItemInfo(param int32) []*protoconf.ItemConf_Item {
	return x.indexItemInfoMap[param]
}

// FindFirstItemInfo finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstItemInfo(param int32) *protoconf.ItemConf_Item {
	val := x.FindItemInfo(param)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: Default@ItemDefaultInfo

// FindItemDefaultInfoMap finds the index (Default@ItemDefaultInfo) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindItemDefaultInfoMap() ItemConf_Index_ItemDefaultInfoMap {
	return x.indexItemDefaultInfoMap
}

// FindItemDefaultInfo finds a slice of all values of the given key.
func (x *ItemConf) FindItemDefaultInfo(default_ string) []*protoconf.ItemConf_Item {
	return x.indexItemDefaultInfoMap[default_]
}

// FindFirstItemDefaultInfo finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstItemDefaultInfo(default_ string) *protoconf.ItemConf_Item {
	val := x.FindItemDefaultInfo(default_)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: ExtType@ItemExtInfo

// FindItemExtInfoMap finds the index (ExtType@ItemExtInfo) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindItemExtInfoMap() ItemConf_Index_ItemExtInfoMap {
	return x.indexItemExtInfoMap
}

// FindItemExtInfo finds a slice of all values of the given key.
func (x *ItemConf) FindItemExtInfo(extType protoconf.FruitType) []*protoconf.ItemConf_Item {
	return x.indexItemExtInfoMap[extType]
}

// FindFirstItemExtInfo finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstItemExtInfo(extType protoconf.FruitType) *protoconf.ItemConf_Item {
	val := x.FindItemExtInfo(extType)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: (ID,Name)<Type,UseEffectType>@AwardItem

// FindAwardItemMap finds the index ((ID,Name)<Type,UseEffectType>@AwardItem) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindAwardItemMap() ItemConf_Index_AwardItemMap {
	return x.indexAwardItemMap
}

// FindAwardItem finds a slice of all values of the given key.
func (x *ItemConf) FindAwardItem(id uint32, name string) []*protoconf.ItemConf_Item {
	return x.indexAwardItemMap[ItemConf_Index_AwardItemKey{id, name}]
}

// FindFirstAwardItem finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstAwardItem(id uint32, name string) *protoconf.ItemConf_Item {
	val := x.FindAwardItem(id, name)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: (ID,Type,Param,ExtType)@SpecialItem

// FindSpecialItemMap finds the index ((ID,Type,Param,ExtType)@SpecialItem) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindSpecialItemMap() ItemConf_Index_SpecialItemMap {
	return x.indexSpecialItemMap
}

// FindSpecialItem finds a slice of all values of the given key.
func (x *ItemConf) FindSpecialItem(id uint32, type_ protoconf.FruitType, param int32, extType protoconf.FruitType) []*protoconf.ItemConf_Item {
	return x.indexSpecialItemMap[ItemConf_Index_SpecialItemKey{id, type_, param, extType}]
}

// FindFirstSpecialItem finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstSpecialItem(id uint32, type_ protoconf.FruitType, param int32, extType protoconf.FruitType) *protoconf.ItemConf_Item {
	val := x.FindSpecialItem(id, type_, param, extType)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: PathDir@ItemPathDir

// FindItemPathDirMap finds the index (PathDir@ItemPathDir) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindItemPathDirMap() ItemConf_Index_ItemPathDirMap {
	return x.indexItemPathDirMap
}

// FindItemPathDir finds a slice of all values of the given key.
func (x *ItemConf) FindItemPathDir(dir string) []*protoconf.ItemConf_Item {
	return x.indexItemPathDirMap[dir]
}

// FindFirstItemPathDir finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstItemPathDir(dir string) *protoconf.ItemConf_Item {
	val := x.FindItemPathDir(dir)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: PathName@ItemPathName

// FindItemPathNameMap finds the index (PathName@ItemPathName) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindItemPathNameMap() ItemConf_Index_ItemPathNameMap {
	return x.indexItemPathNameMap
}

// FindItemPathName finds a slice of all values of the given key.
func (x *ItemConf) FindItemPathName(name string) []*protoconf.ItemConf_Item {
	return x.indexItemPathNameMap[name]
}

// FindFirstItemPathName finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstItemPathName(name string) *protoconf.ItemConf_Item {
	val := x.FindItemPathName(name)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: PathFriendID@ItemPathFriendID

// FindItemPathFriendIDMap finds the index (PathFriendID@ItemPathFriendID) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindItemPathFriendIDMap() ItemConf_Index_ItemPathFriendIDMap {
	return x.indexItemPathFriendIdMap
}

// FindItemPathFriendID finds a slice of all values of the given key.
func (x *ItemConf) FindItemPathFriendID(id uint32) []*protoconf.ItemConf_Item {
	return x.indexItemPathFriendIdMap[id]
}

// FindFirstItemPathFriendID finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstItemPathFriendID(id uint32) *protoconf.ItemConf_Item {
	val := x.FindItemPathFriendID(id)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: UseEffectType@UseEffectType

// FindUseEffectTypeMap finds the index (UseEffectType@UseEffectType) to value (protoconf.ItemConf_Item) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindUseEffectTypeMap() ItemConf_Index_UseEffectTypeMap {
	return x.indexUseEffectTypeMap
}

// FindUseEffectType finds a slice of all values of the given key.
func (x *ItemConf) FindUseEffectType(type_ protoconf.UseEffect_Type) []*protoconf.ItemConf_Item {
	return x.indexUseEffectTypeMap[type_]
}

// FindFirstUseEffectType finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstUseEffectType(type_ protoconf.UseEffect_Type) *protoconf.ItemConf_Item {
	val := x.FindUseEffectType(type_)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedIndex: ExtType@ExtType

// FindExtTypeMap finds the ordered index (ExtType@ExtType) to value (protoconf.ItemConf_Item) treemap.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindExtTypeMap() *ItemConf_OrderedIndex_ExtTypeMap {
	return x.orderedIndexExtTypeMap
}

// FindExtType finds a slice of all values of the given key.
func (x *ItemConf) FindExtType(extType protoconf.FruitType) []*protoconf.ItemConf_Item {
	val, _ := x.orderedIndexExtTypeMap.Get(extType)
	return val
}

// FindFirstExtType finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstExtType(extType protoconf.FruitType) *protoconf.ItemConf_Item {
	val := x.FindExtType(extType)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedIndex: (Param,ExtType)<ID>@ParamExtType

// FindParamExtTypeMap finds the ordered index ((Param,ExtType)<ID>@ParamExtType) to value (protoconf.ItemConf_Item) treemap.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ItemConf) FindParamExtTypeMap() *ItemConf_OrderedIndex_ParamExtTypeMap {
	return x.orderedIndexParamExtTypeMap
}

// FindParamExtType finds a slice of all values of the given key.
func (x *ItemConf) FindParamExtType(param int32, extType protoconf.FruitType) []*protoconf.ItemConf_Item {
	val, _ := x.orderedIndexParamExtTypeMap.Get(ItemConf_OrderedIndex_ParamExtTypeKey{param, extType})
	return val
}

// FindFirstParamExtType finds the first value of the given key,
// or nil if no value found.
func (x *ItemConf) FindFirstParamExtType(param int32, extType protoconf.FruitType) *protoconf.ItemConf_Item {
	val := x.FindParamExtType(param, extType)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedIndex types.
// OrderedIndex: Price<ID>
type FruitConf_OrderedIndex_ItemMap = treemap.TreeMap[int32, []*protoconf.FruitConf_Fruit_Item]

// FruitConf is a wrapper around protobuf message: protoconf.FruitConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type FruitConf struct {
	UnimplementedMessager
	data, originalData   *protoconf.FruitConf
	orderedIndexItemMap  *FruitConf_OrderedIndex_ItemMap
	orderedIndexItemMap1 map[int32]*FruitConf_OrderedIndex_ItemMap
}

// Name returns the FruitConf's message name.
func (x *FruitConf) Name() string {
	return string((*protoconf.FruitConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the FruitConf's inner message data.
func (x *FruitConf) Data() *protoconf.FruitConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills FruitConf's inner message from file in the specified directory and format.
func (x *FruitConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.FruitConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.FruitConf)
	}
	return x.processAfterLoad()
}

// Store writes FruitConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *FruitConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the FruitConf's inner message data.
func (x *FruitConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *FruitConf) Messager() Messager {
	return x
}

// originalMessage returns the FruitConf's original inner message.
func (x *FruitConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// processAfterLoad runs after this messager is loaded.
func (x *FruitConf) processAfterLoad() error {
	// OrderedIndex init.
	x.orderedIndexItemMap = treemap.New[int32, []*protoconf.FruitConf_Fruit_Item]()
	x.orderedIndexItemMap1 = make(map[int32]*FruitConf_OrderedIndex_ItemMap)
	for k1, v1 := range x.data.GetFruitMap() {
		_ = k1
		for k2, v2 := range v1.GetItemMap() {
			_ = k2
			{
				// OrderedIndex: Price<ID>
				key := v2.GetPrice()
				value, _ := x.orderedIndexItemMap.Get(key)
				x.orderedIndexItemMap.Put(key, append(value, v2))
				if x.orderedIndexItemMap1[k1] == nil {
					x.orderedIndexItemMap1[k1] = treemap.New[int32, []*protoconf.FruitConf_Fruit_Item]()
				}
				orderedIndexItemMap1Value, _ := x.orderedIndexItemMap1[k1].Get(key)
				x.orderedIndexItemMap1[k1].Put(key, append(orderedIndexItemMap1Value, v2))
			}
		}
	}
	// OrderedIndex(sort): Price<ID>
	orderedIndexItemMapSorter := func(item []*protoconf.FruitConf_Fruit_Item) func(i, j int) bool {
		return func(i, j int) bool {
			return item[i].GetId() < item[j].GetId()
		}
	}
	x.orderedIndexItemMap.Range(func(key int32, item []*protoconf.FruitConf_Fruit_Item) bool {
		sort.Slice(item, orderedIndexItemMapSorter(item))
		return true
	})
	for _, item := range x.orderedIndexItemMap1 {
		item.Range(func(key int32, item1 []*protoconf.FruitConf_Fruit_Item) bool {
			sort.Slice(item1, orderedIndexItemMapSorter(item1))
			return true
		})
	}
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *FruitConf) Get1(fruitType int32) (*protoconf.FruitConf_Fruit, error) {
	d := x.Data().GetFruitMap()
	if val, ok := d[fruitType]; !ok {
		return nil, fmt.Errorf("fruitType(%v) %w", fruitType, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get2 finds value in the 2-level map. It will return
// NotFound error if the key is not found.
func (x *FruitConf) Get2(fruitType int32, id int32) (*protoconf.FruitConf_Fruit_Item, error) {
	conf, err := x.Get1(fruitType)
	if err != nil {
		return nil, err
	}
	d := conf.GetItemMap()
	if val, ok := d[id]; !ok {
		return nil, fmt.Errorf("id(%v) %w", id, ErrNotFound)
	} else {
		return val, nil
	}
}

// OrderedIndex: Price<ID>

// FindItemMap finds the ordered index (Price<ID>) to value (protoconf.FruitConf_Fruit_Item) treemap.
// One key may correspond to multiple values, which are contained by a slice.
func (x *FruitConf) FindItemMap() *FruitConf_OrderedIndex_ItemMap {
	return x.orderedIndexItemMap
}

// FindItem finds a slice of all values of the given key.
func (x *FruitConf) FindItem(price int32) []*protoconf.FruitConf_Fruit_Item {
	val, _ := x.orderedIndexItemMap.Get(price)
	return val
}

// FindFirstItem finds the first value of the given key,
// or nil if no value found.
func (x *FruitConf) FindFirstItem(price int32) *protoconf.FruitConf_Fruit_Item {
	val := x.FindItem(price)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// FindItemMap1 finds the index (Price<ID>) to value (protoconf.FruitConf_Fruit_Item) treemap
// specified by (fruitType).
// One key may correspond to multiple values, which are contained by a slice.
func (x *FruitConf) FindItemMap1(fruitType int32) *FruitConf_OrderedIndex_ItemMap {
	return x.orderedIndexItemMap1[fruitType]
}

// FindItem1 finds a slice of all values of the given key specified by (fruitType).
func (x *FruitConf) FindItem1(fruitType int32, price int32) []*protoconf.FruitConf_Fruit_Item {
	val, _ := x.FindItemMap1(fruitType).Get(price)
	return val
}

// FindFirstItem1 finds the first value of the given key specified by (fruitType),
// or nil if no value found.
func (x *FruitConf) FindFirstItem1(fruitType int32, price int32) *protoconf.FruitConf_Fruit_Item {
	val := x.FindItem1(fruitType, price)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

func init() {
	Register(func() Messager {
		return new(ItemConf)
	})
	Register(func() Messager {
		return new(FruitConf)
	})
}
