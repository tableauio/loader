// Code generated by protoc-gen-go-tableau-loader. DO NOT EDIT.
// versions:
// - protoc-gen-go-tableau-loader v0.10.1
// - protoc                       v3.19.3
// source: test_conf.proto

package loader

import (
	fmt "fmt"
	pair "github.com/tableauio/loader/pkg/pair"
	treemap "github.com/tableauio/loader/pkg/treemap"
	protoconf "github.com/tableauio/loader/test/go-tableau-loader/protoconf"
	format "github.com/tableauio/tableau/format"
	load "github.com/tableauio/tableau/load"
	store "github.com/tableauio/tableau/store"
	proto "google.golang.org/protobuf/proto"
	sort "sort"
	time "time"
)

// OrderedMap types.
type ActivityConf_OrderedMap_int32Map = treemap.TreeMap[uint32, int32]

type ActivityConf_OrderedMap_protoconf_SectionValue = pair.Pair[*ActivityConf_OrderedMap_int32Map, *protoconf.Section]
type ActivityConf_OrderedMap_protoconf_SectionMap = treemap.TreeMap[uint32, *ActivityConf_OrderedMap_protoconf_SectionValue]

type ActivityConf_OrderedMap_Activity_ChapterValue = pair.Pair[*ActivityConf_OrderedMap_protoconf_SectionMap, *protoconf.ActivityConf_Activity_Chapter]
type ActivityConf_OrderedMap_Activity_ChapterMap = treemap.TreeMap[uint32, *ActivityConf_OrderedMap_Activity_ChapterValue]

type ActivityConf_OrderedMap_ActivityValue = pair.Pair[*ActivityConf_OrderedMap_Activity_ChapterMap, *protoconf.ActivityConf_Activity]
type ActivityConf_OrderedMap_ActivityMap = treemap.TreeMap[uint64, *ActivityConf_OrderedMap_ActivityValue]

// LeveledIndex keys.
type ActivityConf_LeveledIndex_Activity_ChapterKey struct {
	ActivityId uint64
	ChapterId  uint32
}
type ActivityConf_LeveledIndex_protoconf_SectionKey struct {
	ActivityId uint64
	ChapterId  uint32
	SectionId  uint32
}

// Index types.
// Index: ActivityName
type ActivityConf_Index_ActivityMap = map[string][]*protoconf.ActivityConf_Activity

// Index: ChapterID
type ActivityConf_Index_ChapterMap = map[uint32][]*protoconf.ActivityConf_Activity_Chapter

// Index: ChapterName<AwardID>@NamedChapter
type ActivityConf_Index_NamedChapterMap = map[string][]*protoconf.ActivityConf_Activity_Chapter

// Index: SectionItemID@Award
type ActivityConf_Index_AwardMap = map[uint32][]*protoconf.Section_SectionItem

// ActivityConf is a wrapper around protobuf message: protoconf.ActivityConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type ActivityConf struct {
	UnimplementedMessager
	data, originalData    *protoconf.ActivityConf
	orderedMap            *ActivityConf_OrderedMap_ActivityMap
	indexActivityMap      ActivityConf_Index_ActivityMap
	indexChapterMap       ActivityConf_Index_ChapterMap
	indexChapterMap1      map[uint64]ActivityConf_Index_ChapterMap
	indexNamedChapterMap  ActivityConf_Index_NamedChapterMap
	indexNamedChapterMap1 map[uint64]ActivityConf_Index_NamedChapterMap
	indexAwardMap         ActivityConf_Index_AwardMap
	indexAwardMap1        map[uint64]ActivityConf_Index_AwardMap
	indexAwardMap2        map[ActivityConf_LeveledIndex_Activity_ChapterKey]ActivityConf_Index_AwardMap
	indexAwardMap3        map[ActivityConf_LeveledIndex_protoconf_SectionKey]ActivityConf_Index_AwardMap
}

// Name returns the ActivityConf's message name.
func (x *ActivityConf) Name() string {
	return string((*protoconf.ActivityConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the ActivityConf's inner message data.
func (x *ActivityConf) Data() *protoconf.ActivityConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills ActivityConf's inner message from file in the specified directory and format.
func (x *ActivityConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.ActivityConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.ActivityConf)
	}
	return x.processAfterLoad()
}

// Store writes ActivityConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *ActivityConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the ActivityConf's inner message data.
func (x *ActivityConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *ActivityConf) Messager() Messager {
	return x
}

// originalMessage returns the ActivityConf's original inner message.
func (x *ActivityConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// processAfterLoad runs after this messager is loaded.
func (x *ActivityConf) processAfterLoad() error {
	// OrderedMap init.
	x.orderedMap = treemap.New[uint64, *ActivityConf_OrderedMap_ActivityValue]()
	for k1, v1 := range x.Data().GetActivityMap() {
		map1 := x.orderedMap
		k1v := &ActivityConf_OrderedMap_ActivityValue{
			First:  treemap.New[uint32, *ActivityConf_OrderedMap_Activity_ChapterValue](),
			Second: v1,
		}
		map1.Put(k1, k1v)
		for k2, v2 := range v1.GetChapterMap() {
			map2 := k1v.First
			k2v := &ActivityConf_OrderedMap_Activity_ChapterValue{
				First:  treemap.New[uint32, *ActivityConf_OrderedMap_protoconf_SectionValue](),
				Second: v2,
			}
			map2.Put(k2, k2v)
			for k3, v3 := range v2.GetSectionMap() {
				map3 := k2v.First
				k3v := &ActivityConf_OrderedMap_protoconf_SectionValue{
					First:  treemap.New[uint32, int32](),
					Second: v3,
				}
				map3.Put(k3, k3v)
				for k4, v4 := range v3.GetSectionRankMap() {
					map4 := k3v.First
					map4.Put(k4, v4)
				}
			}
		}
	}
	// Index init.
	x.indexActivityMap = make(ActivityConf_Index_ActivityMap)
	x.indexChapterMap = make(ActivityConf_Index_ChapterMap)
	x.indexChapterMap1 = make(map[uint64]ActivityConf_Index_ChapterMap)
	x.indexNamedChapterMap = make(ActivityConf_Index_NamedChapterMap)
	x.indexNamedChapterMap1 = make(map[uint64]ActivityConf_Index_NamedChapterMap)
	x.indexAwardMap = make(ActivityConf_Index_AwardMap)
	x.indexAwardMap1 = make(map[uint64]ActivityConf_Index_AwardMap)
	x.indexAwardMap2 = make(map[ActivityConf_LeveledIndex_Activity_ChapterKey]ActivityConf_Index_AwardMap)
	x.indexAwardMap3 = make(map[ActivityConf_LeveledIndex_protoconf_SectionKey]ActivityConf_Index_AwardMap)
	for k1, v1 := range x.data.GetActivityMap() {
		_ = k1
		{
			// Index: ActivityName
			key := v1.GetActivityName()
			x.indexActivityMap[key] = append(x.indexActivityMap[key], v1)
		}
		for k2, v2 := range v1.GetChapterMap() {
			_ = k2
			{
				// Index: ChapterID
				key := v2.GetChapterId()
				x.indexChapterMap[key] = append(x.indexChapterMap[key], v2)
				if x.indexChapterMap1[k1] == nil {
					x.indexChapterMap1[k1] = make(ActivityConf_Index_ChapterMap)
				}
				x.indexChapterMap1[k1][key] = append(x.indexChapterMap1[k1][key], v2)
			}
			{
				// Index: ChapterName<AwardID>@NamedChapter
				key := v2.GetChapterName()
				x.indexNamedChapterMap[key] = append(x.indexNamedChapterMap[key], v2)
				if x.indexNamedChapterMap1[k1] == nil {
					x.indexNamedChapterMap1[k1] = make(ActivityConf_Index_NamedChapterMap)
				}
				x.indexNamedChapterMap1[k1][key] = append(x.indexNamedChapterMap1[k1][key], v2)
			}
			for k3, v3 := range v2.GetSectionMap() {
				_ = k3
				for k4, v4 := range v3.GetSectionItemList() {
					_ = k4
					{
						// Index: SectionItemID@Award
						key := v4.GetId()
						x.indexAwardMap[key] = append(x.indexAwardMap[key], v4)
						if x.indexAwardMap1[k1] == nil {
							x.indexAwardMap1[k1] = make(ActivityConf_Index_AwardMap)
						}
						x.indexAwardMap1[k1][key] = append(x.indexAwardMap1[k1][key], v4)
						indexAwardMap2Keys := ActivityConf_LeveledIndex_Activity_ChapterKey{k1, k2}
						if x.indexAwardMap2[indexAwardMap2Keys] == nil {
							x.indexAwardMap2[indexAwardMap2Keys] = make(ActivityConf_Index_AwardMap)
						}
						x.indexAwardMap2[indexAwardMap2Keys][key] = append(x.indexAwardMap2[indexAwardMap2Keys][key], v4)
						indexAwardMap3Keys := ActivityConf_LeveledIndex_protoconf_SectionKey{k1, k2, k3}
						if x.indexAwardMap3[indexAwardMap3Keys] == nil {
							x.indexAwardMap3[indexAwardMap3Keys] = make(ActivityConf_Index_AwardMap)
						}
						x.indexAwardMap3[indexAwardMap3Keys][key] = append(x.indexAwardMap3[indexAwardMap3Keys][key], v4)
					}
				}
			}
		}
	}
	// Index(sort): ChapterName<AwardID>@NamedChapter
	indexNamedChapterMapSorter := func(item []*protoconf.ActivityConf_Activity_Chapter) func(i, j int) bool {
		return func(i, j int) bool {
			return item[i].GetAwardId() < item[j].GetAwardId()
		}
	}
	for _, item := range x.indexNamedChapterMap {
		sort.Slice(item, indexNamedChapterMapSorter(item))
	}
	for _, item := range x.indexNamedChapterMap1 {
		for _, item1 := range item {
			sort.Slice(item1, indexNamedChapterMapSorter(item1))
		}
	}
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *ActivityConf) Get1(activityId uint64) (*protoconf.ActivityConf_Activity, error) {
	d := x.Data().GetActivityMap()
	if val, ok := d[activityId]; !ok {
		return nil, fmt.Errorf("activityId(%v) %w", activityId, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get2 finds value in the 2-level map. It will return
// NotFound error if the key is not found.
func (x *ActivityConf) Get2(activityId uint64, chapterId uint32) (*protoconf.ActivityConf_Activity_Chapter, error) {
	conf, err := x.Get1(activityId)
	if err != nil {
		return nil, err
	}
	d := conf.GetChapterMap()
	if val, ok := d[chapterId]; !ok {
		return nil, fmt.Errorf("chapterId(%v) %w", chapterId, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get3 finds value in the 3-level map. It will return
// NotFound error if the key is not found.
func (x *ActivityConf) Get3(activityId uint64, chapterId uint32, sectionId uint32) (*protoconf.Section, error) {
	conf, err := x.Get2(activityId, chapterId)
	if err != nil {
		return nil, err
	}
	d := conf.GetSectionMap()
	if val, ok := d[sectionId]; !ok {
		return nil, fmt.Errorf("sectionId(%v) %w", sectionId, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get4 finds value in the 4-level map. It will return
// NotFound error if the key is not found.
func (x *ActivityConf) Get4(activityId uint64, chapterId uint32, sectionId uint32, key4 uint32) (int32, error) {
	conf, err := x.Get3(activityId, chapterId, sectionId)
	if err != nil {
		return 0, err
	}
	d := conf.GetSectionRankMap()
	if val, ok := d[key4]; !ok {
		return 0, fmt.Errorf("key4(%v) %w", key4, ErrNotFound)
	} else {
		return val, nil
	}
}

// GetOrderedMap returns the 1-level ordered map.
func (x *ActivityConf) GetOrderedMap() *ActivityConf_OrderedMap_ActivityMap {
	return x.orderedMap
}

// GetOrderedMap1 finds value in the 1-level ordered map. It will return
// NotFound error if the key is not found.
func (x *ActivityConf) GetOrderedMap1(activityId uint64) (*ActivityConf_OrderedMap_Activity_ChapterMap, error) {
	conf := x.orderedMap
	if val, ok := conf.Get(activityId); !ok {
		return nil, fmt.Errorf("activityId(%v) %w", activityId, ErrNotFound)
	} else {
		return val.First, nil
	}
}

// GetOrderedMap2 finds value in the 2-level ordered map. It will return
// NotFound error if the key is not found.
func (x *ActivityConf) GetOrderedMap2(activityId uint64, chapterId uint32) (*ActivityConf_OrderedMap_protoconf_SectionMap, error) {
	conf, err := x.GetOrderedMap1(activityId)
	if err != nil {
		return nil, err
	}
	if val, ok := conf.Get(chapterId); !ok {
		return nil, fmt.Errorf("chapterId(%v) %w", chapterId, ErrNotFound)
	} else {
		return val.First, nil
	}
}

// GetOrderedMap3 finds value in the 3-level ordered map. It will return
// NotFound error if the key is not found.
func (x *ActivityConf) GetOrderedMap3(activityId uint64, chapterId uint32, sectionId uint32) (*ActivityConf_OrderedMap_int32Map, error) {
	conf, err := x.GetOrderedMap2(activityId, chapterId)
	if err != nil {
		return nil, err
	}
	if val, ok := conf.Get(sectionId); !ok {
		return nil, fmt.Errorf("sectionId(%v) %w", sectionId, ErrNotFound)
	} else {
		return val.First, nil
	}
}

// Index: ActivityName

// FindActivityMap finds the index (ActivityName) to value (protoconf.ActivityConf_Activity) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindActivityMap() ActivityConf_Index_ActivityMap {
	return x.indexActivityMap
}

// FindActivity finds a slice of all values of the given key.
func (x *ActivityConf) FindActivity(activityName string) []*protoconf.ActivityConf_Activity {
	return x.indexActivityMap[activityName]
}

// FindFirstActivity finds the first value of the given key,
// or nil if no value found.
func (x *ActivityConf) FindFirstActivity(activityName string) *protoconf.ActivityConf_Activity {
	val := x.FindActivity(activityName)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: ChapterID

// FindChapterMap finds the index (ChapterID) to value (protoconf.ActivityConf_Activity_Chapter) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindChapterMap() ActivityConf_Index_ChapterMap {
	return x.indexChapterMap
}

// FindChapter finds a slice of all values of the given key.
func (x *ActivityConf) FindChapter(chapterId uint32) []*protoconf.ActivityConf_Activity_Chapter {
	return x.indexChapterMap[chapterId]
}

// FindFirstChapter finds the first value of the given key,
// or nil if no value found.
func (x *ActivityConf) FindFirstChapter(chapterId uint32) *protoconf.ActivityConf_Activity_Chapter {
	val := x.FindChapter(chapterId)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// FindChapterMap1 finds the index (ChapterID) to value (protoconf.ActivityConf_Activity_Chapter) map
// specified by (activityId).
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindChapterMap1(activityId uint64) ActivityConf_Index_ChapterMap {
	return x.indexChapterMap1[activityId]
}

// FindChapter1 finds a slice of all values of the given key specified by (activityId).
func (x *ActivityConf) FindChapter1(activityId uint64, chapterId uint32) []*protoconf.ActivityConf_Activity_Chapter {
	return x.FindChapterMap1(activityId)[chapterId]
}

// FindFirstChapter1 finds the first value of the given key specified by (activityId),
// or nil if no value found.
func (x *ActivityConf) FindFirstChapter1(activityId uint64, chapterId uint32) *protoconf.ActivityConf_Activity_Chapter {
	val := x.FindChapter1(activityId, chapterId)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: ChapterName<AwardID>@NamedChapter

// FindNamedChapterMap finds the index (ChapterName<AwardID>@NamedChapter) to value (protoconf.ActivityConf_Activity_Chapter) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindNamedChapterMap() ActivityConf_Index_NamedChapterMap {
	return x.indexNamedChapterMap
}

// FindNamedChapter finds a slice of all values of the given key.
func (x *ActivityConf) FindNamedChapter(chapterName string) []*protoconf.ActivityConf_Activity_Chapter {
	return x.indexNamedChapterMap[chapterName]
}

// FindFirstNamedChapter finds the first value of the given key,
// or nil if no value found.
func (x *ActivityConf) FindFirstNamedChapter(chapterName string) *protoconf.ActivityConf_Activity_Chapter {
	val := x.FindNamedChapter(chapterName)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// FindNamedChapterMap1 finds the index (ChapterName<AwardID>@NamedChapter) to value (protoconf.ActivityConf_Activity_Chapter) map
// specified by (activityId).
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindNamedChapterMap1(activityId uint64) ActivityConf_Index_NamedChapterMap {
	return x.indexNamedChapterMap1[activityId]
}

// FindNamedChapter1 finds a slice of all values of the given key specified by (activityId).
func (x *ActivityConf) FindNamedChapter1(activityId uint64, chapterName string) []*protoconf.ActivityConf_Activity_Chapter {
	return x.FindNamedChapterMap1(activityId)[chapterName]
}

// FindFirstNamedChapter1 finds the first value of the given key specified by (activityId),
// or nil if no value found.
func (x *ActivityConf) FindFirstNamedChapter1(activityId uint64, chapterName string) *protoconf.ActivityConf_Activity_Chapter {
	val := x.FindNamedChapter1(activityId, chapterName)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// Index: SectionItemID@Award

// FindAwardMap finds the index (SectionItemID@Award) to value (protoconf.Section_SectionItem) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindAwardMap() ActivityConf_Index_AwardMap {
	return x.indexAwardMap
}

// FindAward finds a slice of all values of the given key.
func (x *ActivityConf) FindAward(id uint32) []*protoconf.Section_SectionItem {
	return x.indexAwardMap[id]
}

// FindFirstAward finds the first value of the given key,
// or nil if no value found.
func (x *ActivityConf) FindFirstAward(id uint32) *protoconf.Section_SectionItem {
	val := x.FindAward(id)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// FindAwardMap1 finds the index (SectionItemID@Award) to value (protoconf.Section_SectionItem) map
// specified by (activityId).
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindAwardMap1(activityId uint64) ActivityConf_Index_AwardMap {
	return x.indexAwardMap1[activityId]
}

// FindAward1 finds a slice of all values of the given key specified by (activityId).
func (x *ActivityConf) FindAward1(activityId uint64, id uint32) []*protoconf.Section_SectionItem {
	return x.FindAwardMap1(activityId)[id]
}

// FindFirstAward1 finds the first value of the given key specified by (activityId),
// or nil if no value found.
func (x *ActivityConf) FindFirstAward1(activityId uint64, id uint32) *protoconf.Section_SectionItem {
	val := x.FindAward1(activityId, id)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// FindAwardMap2 finds the index (SectionItemID@Award) to value (protoconf.Section_SectionItem) map
// specified by (activityId, chapterId).
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindAwardMap2(activityId uint64, chapterId uint32) ActivityConf_Index_AwardMap {
	return x.indexAwardMap2[ActivityConf_LeveledIndex_Activity_ChapterKey{activityId, chapterId}]
}

// FindAward2 finds a slice of all values of the given key specified by (activityId, chapterId).
func (x *ActivityConf) FindAward2(activityId uint64, chapterId uint32, id uint32) []*protoconf.Section_SectionItem {
	return x.FindAwardMap2(activityId, chapterId)[id]
}

// FindFirstAward2 finds the first value of the given key specified by (activityId, chapterId),
// or nil if no value found.
func (x *ActivityConf) FindFirstAward2(activityId uint64, chapterId uint32, id uint32) *protoconf.Section_SectionItem {
	val := x.FindAward2(activityId, chapterId, id)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// FindAwardMap3 finds the index (SectionItemID@Award) to value (protoconf.Section_SectionItem) map
// specified by (activityId, chapterId, sectionId).
// One key may correspond to multiple values, which are contained by a slice.
func (x *ActivityConf) FindAwardMap3(activityId uint64, chapterId uint32, sectionId uint32) ActivityConf_Index_AwardMap {
	return x.indexAwardMap3[ActivityConf_LeveledIndex_protoconf_SectionKey{activityId, chapterId, sectionId}]
}

// FindAward3 finds a slice of all values of the given key specified by (activityId, chapterId, sectionId).
func (x *ActivityConf) FindAward3(activityId uint64, chapterId uint32, sectionId uint32, id uint32) []*protoconf.Section_SectionItem {
	return x.FindAwardMap3(activityId, chapterId, sectionId)[id]
}

// FindFirstAward3 finds the first value of the given key specified by (activityId, chapterId, sectionId),
// or nil if no value found.
func (x *ActivityConf) FindFirstAward3(activityId uint64, chapterId uint32, sectionId uint32, id uint32) *protoconf.Section_SectionItem {
	val := x.FindAward3(activityId, chapterId, sectionId, id)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// ChapterConf is a wrapper around protobuf message: protoconf.ChapterConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type ChapterConf struct {
	UnimplementedMessager
	data, originalData *protoconf.ChapterConf
}

// Name returns the ChapterConf's message name.
func (x *ChapterConf) Name() string {
	return string((*protoconf.ChapterConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the ChapterConf's inner message data.
func (x *ChapterConf) Data() *protoconf.ChapterConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills ChapterConf's inner message from file in the specified directory and format.
func (x *ChapterConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.ChapterConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.ChapterConf)
	}
	return x.processAfterLoad()
}

// Store writes ChapterConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *ChapterConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the ChapterConf's inner message data.
func (x *ChapterConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *ChapterConf) Messager() Messager {
	return x
}

// originalMessage returns the ChapterConf's original inner message.
func (x *ChapterConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *ChapterConf) Get1(id uint64) (*protoconf.ChapterConf_Chapter, error) {
	d := x.Data().GetChapterMap()
	if val, ok := d[id]; !ok {
		return nil, fmt.Errorf("id(%v) %w", id, ErrNotFound)
	} else {
		return val, nil
	}
}

// ThemeConf is a wrapper around protobuf message: protoconf.ThemeConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type ThemeConf struct {
	UnimplementedMessager
	data, originalData *protoconf.ThemeConf
}

// Name returns the ThemeConf's message name.
func (x *ThemeConf) Name() string {
	return string((*protoconf.ThemeConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the ThemeConf's inner message data.
func (x *ThemeConf) Data() *protoconf.ThemeConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills ThemeConf's inner message from file in the specified directory and format.
func (x *ThemeConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.ThemeConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.ThemeConf)
	}
	return x.processAfterLoad()
}

// Store writes ThemeConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *ThemeConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the ThemeConf's inner message data.
func (x *ThemeConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *ThemeConf) Messager() Messager {
	return x
}

// originalMessage returns the ThemeConf's original inner message.
func (x *ThemeConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *ThemeConf) Get1(name string) (*protoconf.ThemeConf_Theme, error) {
	d := x.Data().GetThemeMap()
	if val, ok := d[name]; !ok {
		return nil, fmt.Errorf("name(%v) %w", name, ErrNotFound)
	} else {
		return val, nil
	}
}

// Get2 finds value in the 2-level map. It will return
// NotFound error if the key is not found.
func (x *ThemeConf) Get2(name string, param string) (string, error) {
	conf, err := x.Get1(name)
	if err != nil {
		return "", err
	}
	d := conf.GetParamMap()
	if val, ok := d[param]; !ok {
		return "", fmt.Errorf("param(%v) %w", param, ErrNotFound)
	} else {
		return val, nil
	}
}

// Index types.
// Index: ActivityID<Goal,ID>
type TaskConf_Index_TaskMap = map[int64][]*protoconf.TaskConf_Task

// OrderedIndex types.
// OrderedIndex: Goal<ID>@OrderedTask
type TaskConf_OrderedIndex_OrderedTaskMap = treemap.TreeMap[int64, []*protoconf.TaskConf_Task]

// OrderedIndex: Expiry@TaskExpiry
type TaskConf_OrderedIndex_TaskExpiryMap = treemap.TreeMap[int64, []*protoconf.TaskConf_Task]

// OrderedIndex: Expiry<Goal,ID>@SortedTaskExpiry
type TaskConf_OrderedIndex_SortedTaskExpiryMap = treemap.TreeMap[int64, []*protoconf.TaskConf_Task]

// OrderedIndex: (Expiry,ActivityID)@ActivityExpiry
type TaskConf_OrderedIndex_ActivityExpiryKey struct {
	Expiry     int64
	ActivityId int64
}

func (x TaskConf_OrderedIndex_ActivityExpiryKey) Less(other TaskConf_OrderedIndex_ActivityExpiryKey) bool {
	if x.Expiry != other.Expiry {
		return x.Expiry < other.Expiry
	}
	return x.ActivityId < other.ActivityId
}

type TaskConf_OrderedIndex_ActivityExpiryMap = treemap.TreeMap[TaskConf_OrderedIndex_ActivityExpiryKey, []*protoconf.TaskConf_Task]

// TaskConf is a wrapper around protobuf message: protoconf.TaskConf.
//
// It is designed for three goals:
//
//  1. Easy use: simple yet powerful accessers.
//  2. Elegant API: concise and clean functions.
//  3. Extensibility: Map, OrdererdMap, Index, OrderedIndex...
type TaskConf struct {
	UnimplementedMessager
	data, originalData              *protoconf.TaskConf
	indexTaskMap                    TaskConf_Index_TaskMap
	orderedIndexOrderedTaskMap      *TaskConf_OrderedIndex_OrderedTaskMap
	orderedIndexTaskExpiryMap       *TaskConf_OrderedIndex_TaskExpiryMap
	orderedIndexSortedTaskExpiryMap *TaskConf_OrderedIndex_SortedTaskExpiryMap
	orderedIndexActivityExpiryMap   *TaskConf_OrderedIndex_ActivityExpiryMap
}

// Name returns the TaskConf's message name.
func (x *TaskConf) Name() string {
	return string((*protoconf.TaskConf)(nil).ProtoReflect().Descriptor().Name())
}

// Data returns the TaskConf's inner message data.
func (x *TaskConf) Data() *protoconf.TaskConf {
	if x != nil {
		return x.data
	}
	return nil
}

// Load fills TaskConf's inner message from file in the specified directory and format.
func (x *TaskConf) Load(dir string, format format.Format, opts *load.MessagerOptions) error {
	start := time.Now()
	defer func() {
		x.Stats.Duration = time.Since(start)
	}()
	x.data = &protoconf.TaskConf{}
	err := load.LoadMessagerInDir(x.data, dir, format, opts)
	if err != nil {
		return err
	}
	if x.backup {
		x.originalData = proto.Clone(x.data).(*protoconf.TaskConf)
	}
	return x.processAfterLoad()
}

// Store writes TaskConf's inner message to file in the specified directory and format.
// Available formats: JSON, Bin, and Text.
func (x *TaskConf) Store(dir string, format format.Format, options ...store.Option) error {
	return store.Store(x.Data(), dir, format, options...)
}

// Message returns the TaskConf's inner message data.
func (x *TaskConf) Message() proto.Message {
	return x.Data()
}

// Messager returns the current messager.
func (x *TaskConf) Messager() Messager {
	return x
}

// originalMessage returns the TaskConf's original inner message.
func (x *TaskConf) originalMessage() proto.Message {
	if x != nil {
		return x.originalData
	}
	return nil
}

// processAfterLoad runs after this messager is loaded.
func (x *TaskConf) processAfterLoad() error {
	// Index init.
	x.indexTaskMap = make(TaskConf_Index_TaskMap)
	for k1, v1 := range x.data.GetTaskMap() {
		_ = k1
		{
			// Index: ActivityID<Goal,ID>
			key := v1.GetActivityId()
			x.indexTaskMap[key] = append(x.indexTaskMap[key], v1)
		}
	}
	// Index(sort): ActivityID<Goal,ID>
	indexTaskMapSorter := func(item []*protoconf.TaskConf_Task) func(i, j int) bool {
		return func(i, j int) bool {
			if item[i].GetGoal() != item[j].GetGoal() {
				return item[i].GetGoal() < item[j].GetGoal()
			}
			return item[i].GetId() < item[j].GetId()
		}
	}
	for _, item := range x.indexTaskMap {
		sort.Slice(item, indexTaskMapSorter(item))
	}
	// OrderedIndex init.
	x.orderedIndexOrderedTaskMap = treemap.New[int64, []*protoconf.TaskConf_Task]()
	x.orderedIndexTaskExpiryMap = treemap.New[int64, []*protoconf.TaskConf_Task]()
	x.orderedIndexSortedTaskExpiryMap = treemap.New[int64, []*protoconf.TaskConf_Task]()
	x.orderedIndexActivityExpiryMap = treemap.New2[TaskConf_OrderedIndex_ActivityExpiryKey, []*protoconf.TaskConf_Task]()
	for k1, v1 := range x.data.GetTaskMap() {
		_ = k1
		{
			// OrderedIndex: Goal<ID>@OrderedTask
			key := v1.GetGoal()
			value, _ := x.orderedIndexOrderedTaskMap.Get(key)
			x.orderedIndexOrderedTaskMap.Put(key, append(value, v1))
		}
		{
			// OrderedIndex: Expiry@TaskExpiry
			key := v1.GetExpiry().GetSeconds()
			value, _ := x.orderedIndexTaskExpiryMap.Get(key)
			x.orderedIndexTaskExpiryMap.Put(key, append(value, v1))
		}
		{
			// OrderedIndex: Expiry<Goal,ID>@SortedTaskExpiry
			key := v1.GetExpiry().GetSeconds()
			value, _ := x.orderedIndexSortedTaskExpiryMap.Get(key)
			x.orderedIndexSortedTaskExpiryMap.Put(key, append(value, v1))
		}
		{
			// OrderedIndex: (Expiry,ActivityID)@ActivityExpiry
			key := TaskConf_OrderedIndex_ActivityExpiryKey{v1.GetExpiry().GetSeconds(), v1.GetActivityId()}
			value, _ := x.orderedIndexActivityExpiryMap.Get(key)
			x.orderedIndexActivityExpiryMap.Put(key, append(value, v1))
		}
	}
	// OrderedIndex(sort): Goal<ID>@OrderedTask
	orderedIndexOrderedTaskMapSorter := func(item []*protoconf.TaskConf_Task) func(i, j int) bool {
		return func(i, j int) bool {
			return item[i].GetId() < item[j].GetId()
		}
	}
	x.orderedIndexOrderedTaskMap.Range(func(key int64, item []*protoconf.TaskConf_Task) bool {
		sort.Slice(item, orderedIndexOrderedTaskMapSorter(item))
		return true
	})
	// OrderedIndex(sort): Expiry<Goal,ID>@SortedTaskExpiry
	orderedIndexSortedTaskExpiryMapSorter := func(item []*protoconf.TaskConf_Task) func(i, j int) bool {
		return func(i, j int) bool {
			if item[i].GetGoal() != item[j].GetGoal() {
				return item[i].GetGoal() < item[j].GetGoal()
			}
			return item[i].GetId() < item[j].GetId()
		}
	}
	x.orderedIndexSortedTaskExpiryMap.Range(func(key int64, item []*protoconf.TaskConf_Task) bool {
		sort.Slice(item, orderedIndexSortedTaskExpiryMapSorter(item))
		return true
	})
	return nil
}

// Get1 finds value in the 1-level map. It will return
// NotFound error if the key is not found.
func (x *TaskConf) Get1(id int64) (*protoconf.TaskConf_Task, error) {
	d := x.Data().GetTaskMap()
	if val, ok := d[id]; !ok {
		return nil, fmt.Errorf("id(%v) %w", id, ErrNotFound)
	} else {
		return val, nil
	}
}

// Index: ActivityID<Goal,ID>

// FindTaskMap finds the index (ActivityID<Goal,ID>) to value (protoconf.TaskConf_Task) map.
// One key may correspond to multiple values, which are contained by a slice.
func (x *TaskConf) FindTaskMap() TaskConf_Index_TaskMap {
	return x.indexTaskMap
}

// FindTask finds a slice of all values of the given key.
func (x *TaskConf) FindTask(activityId int64) []*protoconf.TaskConf_Task {
	return x.indexTaskMap[activityId]
}

// FindFirstTask finds the first value of the given key,
// or nil if no value found.
func (x *TaskConf) FindFirstTask(activityId int64) *protoconf.TaskConf_Task {
	val := x.FindTask(activityId)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedIndex: Goal<ID>@OrderedTask

// FindOrderedTaskMap finds the ordered index (Goal<ID>@OrderedTask) to value (protoconf.TaskConf_Task) treemap.
// One key may correspond to multiple values, which are contained by a slice.
func (x *TaskConf) FindOrderedTaskMap() *TaskConf_OrderedIndex_OrderedTaskMap {
	return x.orderedIndexOrderedTaskMap
}

// FindOrderedTask finds a slice of all values of the given key.
func (x *TaskConf) FindOrderedTask(goal int64) []*protoconf.TaskConf_Task {
	val, _ := x.orderedIndexOrderedTaskMap.Get(goal)
	return val
}

// FindFirstOrderedTask finds the first value of the given key,
// or nil if no value found.
func (x *TaskConf) FindFirstOrderedTask(goal int64) *protoconf.TaskConf_Task {
	val := x.FindOrderedTask(goal)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedIndex: Expiry@TaskExpiry

// FindTaskExpiryMap finds the ordered index (Expiry@TaskExpiry) to value (protoconf.TaskConf_Task) treemap.
// One key may correspond to multiple values, which are contained by a slice.
func (x *TaskConf) FindTaskExpiryMap() *TaskConf_OrderedIndex_TaskExpiryMap {
	return x.orderedIndexTaskExpiryMap
}

// FindTaskExpiry finds a slice of all values of the given key.
func (x *TaskConf) FindTaskExpiry(expiry int64) []*protoconf.TaskConf_Task {
	val, _ := x.orderedIndexTaskExpiryMap.Get(expiry)
	return val
}

// FindFirstTaskExpiry finds the first value of the given key,
// or nil if no value found.
func (x *TaskConf) FindFirstTaskExpiry(expiry int64) *protoconf.TaskConf_Task {
	val := x.FindTaskExpiry(expiry)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedIndex: Expiry<Goal,ID>@SortedTaskExpiry

// FindSortedTaskExpiryMap finds the ordered index (Expiry<Goal,ID>@SortedTaskExpiry) to value (protoconf.TaskConf_Task) treemap.
// One key may correspond to multiple values, which are contained by a slice.
func (x *TaskConf) FindSortedTaskExpiryMap() *TaskConf_OrderedIndex_SortedTaskExpiryMap {
	return x.orderedIndexSortedTaskExpiryMap
}

// FindSortedTaskExpiry finds a slice of all values of the given key.
func (x *TaskConf) FindSortedTaskExpiry(expiry int64) []*protoconf.TaskConf_Task {
	val, _ := x.orderedIndexSortedTaskExpiryMap.Get(expiry)
	return val
}

// FindFirstSortedTaskExpiry finds the first value of the given key,
// or nil if no value found.
func (x *TaskConf) FindFirstSortedTaskExpiry(expiry int64) *protoconf.TaskConf_Task {
	val := x.FindSortedTaskExpiry(expiry)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

// OrderedIndex: (Expiry,ActivityID)@ActivityExpiry

// FindActivityExpiryMap finds the ordered index ((Expiry,ActivityID)@ActivityExpiry) to value (protoconf.TaskConf_Task) treemap.
// One key may correspond to multiple values, which are contained by a slice.
func (x *TaskConf) FindActivityExpiryMap() *TaskConf_OrderedIndex_ActivityExpiryMap {
	return x.orderedIndexActivityExpiryMap
}

// FindActivityExpiry finds a slice of all values of the given key.
func (x *TaskConf) FindActivityExpiry(expiry int64, activityId int64) []*protoconf.TaskConf_Task {
	val, _ := x.orderedIndexActivityExpiryMap.Get(TaskConf_OrderedIndex_ActivityExpiryKey{expiry, activityId})
	return val
}

// FindFirstActivityExpiry finds the first value of the given key,
// or nil if no value found.
func (x *TaskConf) FindFirstActivityExpiry(expiry int64, activityId int64) *protoconf.TaskConf_Task {
	val := x.FindActivityExpiry(expiry, activityId)
	if len(val) > 0 {
		return val[0]
	}
	return nil
}

func init() {
	Register(func() Messager {
		return new(ActivityConf)
	})
	Register(func() Messager {
		return new(ChapterConf)
	})
	Register(func() Messager {
		return new(ThemeConf)
	})
	Register(func() Messager {
		return new(TaskConf)
	})
}
